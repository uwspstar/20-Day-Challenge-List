### Python 中的堆数据结构

在 Python 中，堆是一种特殊的数据结构，通常用于实现**优先队列**。Python 标准库中提供了 `heapq` 模块，它实现了一个**最小堆**（min-heap），使得堆顶元素始终是最小值。虽然 `heapq` 默认提供最小堆的功能，我们也可以通过一些技巧将其用作最大堆。

#### 堆的特点
堆是一种**完全二叉树**，具有以下特点：
1. **最小堆**：每个父节点的值都小于等于其子节点的值，根节点为最小值。
2. **最大堆**：每个父节点的值都大于等于其子节点的值，根节点为最大值。

#### 为什么使用堆？
堆的主要特点是能够在**对数时间复杂度 O(log n)** 下进行插入和删除操作，非常适合需要频繁查询最小值或最大值的场景。例如：找出一组数据中的前 K 小（或大）元素。

#### Python 中的 `heapq` 模块

`heapq` 模块提供了一组堆操作的函数，包括插入、删除、获取最小元素等。以下是一些常用函数：

1. **`heapq.heappush(heap, item)`**：将元素 `item` 添加到堆 `heap` 中，并保持堆的性质。
2. **`heapq.heappop(heap)`**：删除并返回堆 `heap` 中的最小元素。操作会自动维护堆的结构。
3. **`heapq.heappushpop(heap, item)`**：先将元素 `item` 添加到堆中，再弹出并返回堆中最小的元素。
4. **`heapq.heapify(heap)`**：将列表 `heap` 转换为堆结构，就地调整顺序，时间复杂度为 `O(n)`。

#### 示例：最小堆的使用
假设我们有一组任务，按优先级排列，优先级越小，任务越重要。我们可以使用 `heapq` 来管理这些任务：

```python
import heapq

tasks = []
heapq.heappush(tasks, (1, "修复紧急Bug"))  # 优先级 1
heapq.heappush(tasks, (3, "完善文档"))      # 优先级 3
heapq.heappush(tasks, (2, "代码审查"))      # 优先级 2

# 获取优先级最高的任务
print(heapq.heappop(tasks))  # 输出: (1, '修复紧急Bug')
```

#### 最大堆的实现方法
Python 默认不支持最大堆，但可以通过将数字取负值的技巧来实现最大堆。

```python
import heapq

# 使用负数来实现最大堆
max_heap = []
heapq.heappush(max_heap, -10)
heapq.heappush(max_heap, -30)
heapq.heappush(max_heap, -20)

# 删除并返回最大值
最大值 = -heapq.heappop(max_heap)
print(最大值)  # 输出：30
```

#### 使用场景
堆结构在以下场景中非常有用：
- **找到数据中的最小或最大元素**，如找到数组的最小 K 个元素。
- **优先队列**，如任务调度中的任务按优先级处理。
- **实时数据流处理**，如在一个数据流中始终保持前 K 大/小的元素。

#### 总结
- 堆是一种特殊的完全二叉树，用于快速获取最小或最大元素。
- Python 的 `heapq` 模块实现了最小堆，提供插入、删除和查询最小元素的功能。
- 可以使用负数转换的方法来实现最大堆。

---

### 优先队列和堆

### 什么是优先队列和堆的关系？

优先队列是一种**抽象数据类型**（ADT），而堆是我们实现优先队列的具体**数据结构**。优先队列是一种能按优先级插入和删除元素的数据结构，而堆是一种树形结构，能高效地管理优先级顺序。

---

### 优先队列

优先队列是一个包含若干元素的数据结构，支持以下操作：

- `insert`：插入带有优先级的元素。
- `delete_min/delete_max`：移除优先级最低或最高的元素并返回。

**注意**：我们只能获取并删除优先级最小或最大的元素，而不能获取任意优先级的元素。

#### 使用场景

- **医院分诊**：患者按病情严重程度排序，病情越严重，优先级越高。
- **合并 K 个已排序链表**：优先队列可用于跟踪每个链表中的最小值。
- **其他常见问题**：
  - 距离原点最近的 K 个点
  - 数据流中第 K 大的元素
  - 数据流的中位数
  - 均匀成本搜索（Uniform Cost Search）

#### 使用数组实现优先队列

可以尝试使用不同的数组结构来实现优先队列：

- **无序数组**：插入操作为 \(O(1)\)，但查找和删除最小值需要 \(O(N)\)。
- **有序数组**：查找最小值为 \(O(1)\)，但插入操作需要 \(O(N)\) 来保持数组的排序状态。

两者都不够高效，因此我们引入堆来优化。

---

### 堆

堆是一种特殊的**树形数据结构**，通常是**二叉堆**，但也可以是 K 叉堆。堆有两种常见形式：

- **最小堆（Min Heap）**：每个节点的值大于等于其父节点的值。
- **最大堆（Max Heap）**：每个节点的值小于等于其父节点的值。

堆具有以下特性：

1. **完全二叉树**：堆总是填满每一层，除了可能的最后一层。
2. **堆属性**：
   - **最小堆**：每个节点的优先级大于等于父节点的优先级。
   - **最大堆**：每个节点的优先级小于等于父节点的优先级。

#### 堆的特性

堆的结构虽然看似有些奇怪，但它非常有用：

- **快速插入和删除**：由于堆的高度为 \(O(\log(N))\)，插入和删除的时间复杂度均为 \(O(\log(N))\)。
- **使用数组存储**：堆作为完全二叉树可以使用数组来存储，无需指针操作，父节点和子节点可通过索引计算得出。

---

### 堆的常见操作

1. **插入**：将新节点插入到第一个空闲叶子位置上，如果堆属性被破坏，则通过**上浮**操作恢复堆结构。
   
   ```python
   def bubble_up(node):
       while node.parent and node.parent.key > node.key:
           swap(node, node.parent)
           node = node.parent
   ```

2. **删除最小值**（对于最小堆）：
   - 移除根节点，将堆的最后一个节点移动到根节点位置。
   - 如果堆属性被破坏，则通过**下沉**操作恢复结构。

   ```python
   def bubble_down(node):
       while not node.is_leaf():
           smallest_child = child of node with smallest key
           if smallest_child.key < node.key:
               swap(node, smallest_child)
               node = smallest_child
           else:
               break
   ```

### 实现堆

由于堆是完全二叉树，可以使用数组来实现，每个节点的索引位置可以用公式快速确定其父节点和子节点的位置：

- 对于节点 `i`，左子节点在 `2*i + 1`，右子节点在 `2*i + 2`，父节点在 `(i - 1) // 2`。

Python 中有一个内置的 `heapq` 模块用于实现最小堆：

```python
import heapq
h = []
heapq.heappush(h, (5, '任务A'))
heapq.heappush(h, (1, '任务B'))
print(heapq.heappop(h))  # 输出：(1, '任务B')
```

---

### 关键总结

- **堆** 是一种完全二叉树，适合优先队列的实现。
- **最小堆** 可以快速找到和删除最小元素，时间复杂度为 \(O(\log(N))\)。
- **Python 的 `heapq` 模块** 可以方便地实现最小堆，用于优先级任务的管理。
