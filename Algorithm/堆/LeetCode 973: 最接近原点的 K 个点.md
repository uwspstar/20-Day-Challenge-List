### LeetCode 973: K Closest Points to Origin

https://leetcode.com/problems/k-closest-points-to-origin/

**题目描述**：
给定一个二维平面上的点列表，找到离原点 (0, 0) 最近的 k 个点。

**示例**：

输入：`[(1, 1), (2, 2), (3, 3)]`, `k = 1`  
输出：`[(1, 1)]`

**代码实现**：
```python
# 导入堆模块
import heapq

# 定义解决方案的类
class Solution:
    # 定义查找最近 k 个点的函数
    def kClosest(self, points, k):
        # 创建一个最大堆来存储距离最小的点
        max_heap = []
        
        # 遍历所有的点
        for x, y in points:
            # 计算每个点到原点的欧几里得距离的平方（省略平方根，比较距离平方即可）
            distance = -(x ** 2 + y ** 2)
            # 将点和距离入堆
            heapq.heappush(max_heap, (distance, (x, y)))
            # 如果堆的大小超过 k，则弹出最远的点
            if len(max_heap) > k:
                heapq.heappop(max_heap)
        
        # 从堆中取出最近的 k 个点
        return [point for (_, point) in max_heap]

# 示例调用
points = [(1, 1), (2, 2), (3, 3)]
k = 1
solution = Solution()
print(solution.kClosest(points, k))  # 输出 [(1, 1)]
```

### 代码解析：
1. **导入堆模块**：
   ```python
   import heapq
   ```
   - `heapq` 模块提供了堆的实现，适用于优先队列操作。
   - 在此题中，使用最大堆来存储距离最小的点。

2. **定义类和函数**：
   ```python
   class Solution:
       def kClosest(self, points, k):
   ```
   - `Solution` 是主类。
   - `kClosest` 函数接受一个点列表 `points` 和整数 `k`，返回距离原点最近的 `k` 个点。

3. **初始化最大堆**：
   ```python
   max_heap = []
   ```
   - `max_heap` 是最大堆，用于存储 `k` 个距离最小的点。

4. **遍历每个点**：
   ```python
   for x, y in points:
       distance = -(x ** 2 + y ** 2)
       heapq.heappush(max_heap, (distance, (x, y)))
   ```
   - `x, y` 是每个点的坐标。
   - `distance` 计算每个点到原点的距离的平方。为了方便最大堆比较，取距离的负值，使得更接近的点更优先保留在堆中。
   - `heapq.heappush` 将点及其距离推入堆。

5. **控制堆的大小**：
   ```python
   if len(max_heap) > k:
       heapq.heappop(max_heap)
   ```
   - 如果堆大小超过 `k`，则弹出距离最远的点，确保堆内保留 `k` 个最近的点。

6. **返回结果**：
   ```python
   return [point for (_, point) in max_heap]
   ```
   - 使用列表推导式提取堆中保存的 `k` 个点并返回。

### 时间复杂度分析 (Big O)：
- **时间复杂度**：O(N log K)，其中 `N` 是点的数量，`K` 是所需的最近点数。每次 `heappush` 和 `heappop` 操作需要 O(log K) 时间。
- **空间复杂度**：O(K)，用于存储堆中的最近点。

### 示例讲解：

给定输入 `[(1, 1), (2, 2), (3, 3)]` 和 `k = 1`，我们逐步运行代码：

1. **初始化**：
   - 最大堆 `max_heap = []`

2. **遍历第一个点 `(1, 1)`**：
   - 计算距离平方：`distance = -(1^2 + 1^2) = -2`
   - 将 `(-2, (1, 1))` 插入堆中，`max_heap = [(-2, (1, 1))]`

3. **遍历第二个点 `(2, 2)`**：
   - 计算距离平方：`distance = -(2^2 + 2^2) = -8`
   - 将 `(-8, (2, 2))` 插入堆中，`max_heap = [(-8, (2, 2)), (-2, (1, 1))]`
   - 堆大小超过 `k = 1`，弹出最远的点，弹出 `(-8, (2, 2))`
   - `max_heap = [(-2, (1, 1))]`

4. **遍历第三个点 `(3, 3)`**：
   - 计算距离平方：`distance = -(3^2 + 3^2) = -18`
   - 将 `(-18, (3, 3))` 插入堆中，`max_heap = [(-18, (3, 3)), (-2, (1, 1))]`
   - 堆大小超过 `k = 1`，弹出最远的点，弹出 `(-18, (3, 3))`
   - `max_heap = [(-2, (1, 1))]`

5. **返回结果**：
   - 提取堆中的点，返回 `[(1, 1)]`

---

在上面的代码中，我们使用了 **最大堆 (max_heap)**，而不是 **最小堆 (min_heap)**，这是为了有效地找到距离最近的 `k` 个点。以下是原因：

### 1. 使用最大堆的思路
我们希望在遍历所有点的过程中，始终保留距离最近的 `k` 个点。这就意味着每次我们找到一个新的点时，如果这个点比当前保存的点更接近原点，我们就需要替换掉当前距离最远的点。因此，我们使用了最大堆，将**离原点最远的点**放在堆的顶部（堆的根节点），这样可以随时删除它，保持堆中只有 `k` 个最接近的点。

在代码中，我们计算每个点到原点的距离的平方，并取其**负值**来存入最大堆，这样最小的负值对应最近的点，堆顶的值就是当前 `k` 个点中距离最远的点。

### 2. 为什么不使用最小堆
如果使用 **最小堆 (min_heap)**，则堆顶会是**距离最近的点**，这并不利于我们维护 `k` 个最近点的集合。使用最小堆时，我们无法有效地控制堆的大小，也很难在找到距离更近的点时移除距离较远的点。所以使用最小堆会导致算法复杂度增加，不适合这种需求。

### 3. 代码中的实现细节
在代码中，我们通过将距离的负值存入最大堆，保证了堆顶始终是 `k` 个点中距离最远的点。一旦堆的大小超过 `k`，我们就会弹出堆顶元素，确保保留的都是距离最近的 `k` 个点。

### 总结
使用最大堆能够更高效地解决这个问题，因为它允许我们在 `O(log k)` 的时间复杂度下移除最远的点，而 `min_heap` 无法做到这一点。因此，使用最大堆更适合这种找到最近 `k` 个点的问题。
