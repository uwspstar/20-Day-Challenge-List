### LeetCode 题目：[973. 最接近原点的 K 个点](https://leetcode.cn/problems/k-closest-points-to-origin/)

**题目描述**：

给定一个点集 `points`，其中每个点的坐标为整数 `(x, y)`，以及一个整数 `K`。请找到距离原点 `(0, 0)` 最近的 `K` 个点。

距离的计算方法为欧几里得距离，但在比较距离大小时，可以使用距离的平方来避免计算平方根。

**示例 1**：

```
输入：points = [[1,3],[-2,2]], K = 1
输出：[[-2,2]]
解释：
(1, 3) 与原点的距离为 sqrt(1² + 3²) = sqrt(10)
(-2, 2) 与原点的距离为 sqrt((-2)² + 2²) = sqrt(8)
因此，最接近原点的 1 个点是 [-2,2]
```

**示例 2**：

```
输入：points = [[3,3],[5,-1],[-2,4]], K = 2
输出：[[3,3],[-2,4]]
（答案 [[-2,4],[3,3]] 也被接受）
```

**提示**：

- 1 <= K <= points.length <= 10^4
- -10^4 < x_i, y_i < 10^4

---

**解题思路**：

1. **计算距离**：对于每个点，计算其到原点的距离的平方，避免计算平方根，提高效率。
2. **使用最大堆**：维护一个大小为 K 的最大堆，堆中存储当前离原点最近的 K 个点。
   - 如果新的点比堆中最远的点更近，则替换堆顶元素。
3. **返回结果**：堆中剩下的就是距离原点最近的 K 个点。

**注意**：由于 Python 的 `heapq` 实现的是最小堆，为了模拟最大堆，我们可以将距离取反。

---

**代码实现**：

```python
import heapq
from typing import List

class Solution:
    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:
        # 定义最大堆
        max_heap = []
        
        for (x, y) in points:
            # 计算距离的平方
            dist = x * x + y * y
            # 将距离取反，模拟最大堆
            heapq.heappush(max_heap, (-dist, [x, y]))
            # 维护堆的大小为 K
            if len(max_heap) > K:
                heapq.heappop(max_heap)
                
        # 提取堆中的点
        return [point for (_, point) in max_heap]
```

---

**复杂度分析**：

- **时间复杂度**：O(N log K)，其中 N 是点的数量。
  - 对于每个点，堆操作的时间复杂度为 O(log K)。
- **空间复杂度**：O(K)，最大堆中最多存储 K 个元素。

---

**示例讲解**：

以示例 2 为例：

输入：`points = [[3,3],[5,-1],[-2,4]], K = 2`

1. **初始化**：`max_heap = []`

2. **遍历第一个点 [3,3]**：
   - 计算距离平方：`dist = 3^2 + 3^2 = 18`
   - 将 (-18, [3,3]) 压入堆：`max_heap = [(-18, [3,3])]`

3. **遍历第二个点 [5,-1]**：
   - 计算距离平方：`dist = 5^2 + (-1)^2 = 26`
   - 将 (-26, [5,-1]) 压入堆：`max_heap = [(-26, [5,-1]), (-18, [3,3])]`
   - 堆大小超过 K，弹出堆顶元素（距离最远的点）：`max_heap = [(-18, [3,3])]`

4. **遍历第三个点 [-2,4]**：
   - 计算距离平方：`dist = (-2)^2 + 4^2 = 20`
   - 将 (-20, [-2,4]) 压入堆：`max_heap = [(-20, [-2,4]), (-18, [3,3])]`
   - 堆大小超过 K，弹出堆顶元素：`max_heap = [(-18, [3,3]), (-20, [-2,4])]`

5. **最终堆中元素**：
   - `max_heap = [(-20, [-2,4]), (-18, [3,3])]`

6. **返回结果**：
   - 提取堆中的点，得到 `[[3,3], [-2,4]]` 或 `[[−2,4], [3,3]]`

---

**拓展**：

如果 K 接近 N，使用排序可能更高效：

```python
class Solution:
    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:
        # 按照距离排序
        points.sort(key=lambda P: P[0] * P[0] + P[1] * P[1])
        # 返回前 K 个点
        return points[:K]
```

- **时间复杂度**：O(N log N)
- **适用场景**：当 K 接近 N 时，排序的方法效率更高。

---

**总结**：

- **理解问题本质**：寻找距离最近的 K 个点，可以使用排序或堆的方法。
- **选择合适的数据结构**：根据 K 与 N 的关系，选择排序或堆，以达到最佳效率。
- **掌握堆的使用技巧**：在 Python 中使用 `heapq` 模块，实现最大堆需要取负值。

---

**注意事项**：

- 当使用堆时，确保正确维护堆的大小，避免内存溢出。
- 当比较距离大小时，使用距离的平方即可，无需计算平方根，节省计算时间。
