### LeetCode 776: [Split BST](https://leetcode.com/problems/split-bst/)

---

## 题目描述

给定一棵二叉搜索树 (BST) 和一个值 `V`，将树分成两棵子树，其中一棵子树包含所有小于或等于 `V` 的节点，另一棵子树包含所有大于 `V` 的节点。返回这两棵树的根节点作为长度为 2 的列表。

---

### 示例 1:

```
输入: root = [4,2,6,1,3,5,7], V = 2
输出: [[2,1],[4,3,6,null,null,5,7]]
解释:
输入的二叉搜索树如下图所示：
       4
     /   \
    2     6
   / \   / \
  1   3 5   7

输出的两棵二叉搜索树分别是：
1. 小于等于 2 的子树:
       2
     /
    1

2. 大于 2 的子树:
       4
     /   \
    3     6
         / \
        5   7
```

---

### 解题思路

这是一个典型的递归问题。我们可以利用 BST 的特性来解决这个问题。给定节点的值 `root.val` 和给定的分界值 `V` 进行比较，并递归处理子树：

- **如果 `root.val <= V`**：表示当前节点及其左子树的所有节点都属于小于等于 `V` 的子树。那么我们递归地对 `root.right` 执行 `splitBST`，并将返回的左子树作为 `root.right`，表示 `V` 右侧部分应该分到新的子树中。
- **如果 `root.val > V`**：表示当前节点及其右子树的所有节点都属于大于 `V` 的子树。此时，我们递归地对 `root.left` 执行 `splitBST`，并将返回的右子树作为 `root.left`。

最终，我们返回分割后的两棵子树。

---

### 代码实现

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def splitBST(self, root: TreeNode, V: int):
        if not root:
            return [None, None]
        
        if root.val <= V:
            # 当前节点属于小于等于 V 的子树
            left_tree, right_tree = self.splitBST(root.right, V)
            root.right = left_tree  # 将左子树部分分配给 root 的右节点
            return [root, right_tree]  # root 和右子树分别返回
        
        else:
            # 当前节点属于大于 V 的子树
            left_tree, right_tree = self.splitBST(root.left, V)
            root.left = right_tree  # 将右子树部分分配给 root 的左节点
            return [left_tree, root]  # 左子树和 root 分别返回
```

---

### 代码解释

1. **基础情况**：
   - 当 `root` 为空时，返回 `[None, None]`，表示没有子树。
   
2. **递归判断**：
   - 如果当前节点的值小于等于 `V`，则当前节点及其左子树属于小于等于 `V` 的子树。我们递归地对 `root.right` 进行分割，返回的左子树将分配给 `root.right`。
   - 如果当前节点的值大于 `V`，则当前节点及其右子树属于大于 `V` 的子树。我们递归地对 `root.left` 进行分割，返回的右子树将分配给 `root.left`。

3. **返回值**：
   - 最终返回分割后的两棵子树。第一棵子树包含所有小于等于 `V` 的节点，第二棵子树包含所有大于 `V` 的节点。

---

### 复杂度分析

- **时间复杂度**：O(n)，其中 `n` 是树中的节点数。我们需要遍历所有节点一次来分割树。
- **空间复杂度**：O(n)，递归栈的深度最坏情况下可能是树的高度。

---

### 示例讲解

#### 示例 1:

```
输入: root = [4,2,6,1,3,5,7], V = 2
```

- 根节点 `root.val = 4`，`4 > V = 2`，所以递归分割 `root.left`。
- 在 `root.left = 2` 的子树上递归，`2 <= V`，所以我们递归分割 `root.right`，即节点 `3`。
- 最终返回结果为两棵子树：

```
1. 小于等于 2 的子树：
    2
   /
  1

2. 大于 2 的子树：
    4
   /   \
  3     6
       / \
      5   7
```

---

### 递归过程详解（以二叉搜索树分割为例）

我们来看这个二叉搜索树的结构：

```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13
```

假设我们要以 `V = 6` 为分界点，将这棵二叉搜索树分割成两棵树：一棵包含所有小于等于 `6` 的节点，另一棵包含所有大于 `6` 的节点。这个操作可以通过递归实现，下面我们一步步解释递归的过程。

### 递归的核心逻辑：

1. **当前节点值 `<= V`**：当前节点及其左子树都属于小于等于 `V` 的部分，我们需要对其右子树递归进行分割。
2. **当前节点值 `> V`**：当前节点及其右子树都属于大于 `V` 的部分，我们需要对其左子树递归进行分割。

---

### 递归过程：

1. **从根节点 `8` 开始**：
   - 当前节点 `8` 大于 `V = 6`，所以 `8` 及其右子树应该属于大于 `6` 的子树。
   - 递归处理 `root.left = 3`，以继续处理小于等于 `6` 的子树。

2. **处理节点 `3`**：
   - 当前节点 `3` 小于 `V = 6`，因此 `3` 和它的左子树（`1`）都属于小于等于 `6` 的子树。
   - 但是 `3` 的右子树是 `6`，我们需要递归处理 `root.right = 6` 来决定如何分配该部分。

3. **处理节点 `6`**：
   - 当前节点是分界点 `6`，它的值等于 `V`，因此 `6` 及其左子树（`4`）属于小于等于 `6` 的子树。
   - 但是 `6` 的右子树是 `7`，`7 > V`，所以我们需要将 `7` 放到大于 `6` 的子树中。
   - 递归处理 `root.right = 7`，返回 `[None, 7]`，表示 `7` 属于大于 `6` 的子树，而 `6` 的右子树设为 `None`。

4. **回到节点 `3`**：
   - 现在 `6` 的右子树是 `None`，递归返回时，`6` 和它的左子树组成了小于等于 `6` 的部分。
   - `3` 的左子树保持不变，右子树成为 `6`。于是 `3` 及其左、右子树属于小于等于 `6` 的部分。
   - 递归返回 `[3, 8]`，表示小于等于 `6` 的部分是 `3`，大于 `6` 的部分是 `8`。

5. **处理右子树 `10` 和 `14`**：
   - 回到根节点 `8`，因为 `8 > 6`，我们将递归处理完的右子树保持不变，即 `10` 和 `14` 继续属于大于 `6` 的部分，无需进一步处理。

---

### 最终分割结果：

- **小于等于 6 的子树**：
```
      3
     / \
    1   6
       /
      4
```

- **大于 6 的子树**：
```
      8
       \
       10
         \
         14
        /
       13
      /
     7
```

---

### 递归的要点：

1. **递归拆分左右子树**：
   - 对于每个节点，我们根据其值与 `V` 的关系，决定是否继续递归分割其左子树或右子树。
   - 小于等于 `V` 的节点会递归处理右子树，大于 `V` 的节点会递归处理左子树。

2. **回溯并组装结果**：
   - 递归处理完成后，当前节点会将其左子树或右子树根据返回的结果进行重新连接，最终形成两个完整的子树。
   
3. **保持二叉搜索树的结构**：
   - 每次递归处理时，我们都保证子树的节点保持 BST 的性质，确保左子树的值小于当前节点，右子树的值大于当前节点。

通过递归分割的方式，我们可以将整个树有效地拆分成两部分，分别包含小于等于 `V` 和大于 `V` 的节点。
