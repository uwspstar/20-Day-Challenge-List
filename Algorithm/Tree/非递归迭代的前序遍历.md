### 迭代的前序遍历（非递归）

为了在不使用递归的情况下进行**前序遍历**，我们可以使用**栈**来记录节点的路径，并按前序遍历（即**根-左-右**的顺序）依次访问节点。

#### 代码实现：

```python
from typing import Optional, List

# 定义二叉树节点类
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []  # 如果根节点为空，直接返回空列表

        res = []  # 初始化结果列表
        stk = [root]  # 初始化栈，将根节点入栈

        # 当栈不为空时继续遍历
        while stk:
            cur = stk.pop()  # 弹出栈顶节点
            res.append(cur.val)  # 将当前节点的值添加到结果列表

            # 先将右子节点入栈，再将左子节点入栈
            # 这样确保下次遍历时先访问左子节点
            if cur.right:
                stk.append(cur.right)
            if cur.left:
                stk.append(cur.left)

        return res  # 返回前序遍历的结果
```

---

### 代码解释：

1. **初始化栈和结果列表**：
   - 如果根节点为空，直接返回空列表。
   - `res` 用于存储前序遍历的结果。
   - `stk` 是一个栈，初始状态将根节点入栈。

2. **迭代遍历**：
   - 当栈不为空时，循环执行以下操作。

3. **访问当前节点**：
   - 弹出栈顶节点，并将其值添加到结果列表 `res`。

4. **压入子节点**：
   - 先将右子节点压入栈，再将左子节点压入栈。
   - 这样可以确保下次遍历时优先访问左子节点，因为栈是**后进先出**的。

5. **返回结果**：
   - 最后返回前序遍历的结果列表 `res`。

---

### 复杂度分析：

- **时间复杂度**：O(n)，其中 `n` 是树中节点的数量。每个节点最多被访问一次。
- **空间复杂度**：O(H)，其中 `H` 是树的高度。这是栈的最大深度。

---

### 示例分析：

#### 示例：

```python
输入: root = [1, None, 2, 3]
```

树的结构：

```
    1
     \
      2
     /
    3
```

1. **初始状态**：
   - `stk = [1]`，`res = []`。

2. **访问节点**：
   - 弹出 `1`，添加到结果：`res = [1]`。
   - 将右子节点 `2` 压入栈：`stk = [2]`。

3. **访问节点**：
   - 弹出 `2`，添加到结果：`res = [1, 2]`。
   - 将左子节点 `3` 压入栈：`stk = [3]`。

4. **访问节点**：
   - 弹出 `3`，添加到结果：`res = [1, 2, 3]`。

5. **返回结果**：
   - 最终 `res = [1, 2, 3]`。

---

### 总结：

- 通过使用栈模拟递归过程，我们可以在不使用递归的情况下进行前序遍历。
- 这种方法高效且适用于大型树结构，因为它避免了递归的开销和栈深度限制。
- **前序遍历**中，根节点总是优先被访问，因此要在压入栈时先压右子节点，再压左子节点。
