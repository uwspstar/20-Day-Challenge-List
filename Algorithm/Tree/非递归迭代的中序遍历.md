### 迭代的中序遍历（非递归）

为了在不使用递归的情况下进行**中序遍历**，我们可以使用**栈**来记录节点的路径，并按中序遍历（即**左-根-右**的顺序）依次访问节点。

#### 代码实现：

```python
from typing import Optional, List

# 定义二叉树节点类
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []  # 初始化结果列表
        stk = []  # 初始化栈
        cur = root  # 从根节点开始

        # 当当前节点存在或栈不为空时继续遍历
        while cur or stk:
            # 移动到最左子节点
            while cur:
                stk.append(cur)  # 将当前节点入栈
                cur = cur.left  # 移动到左子节点
            
            # 弹出栈顶节点
            cur = stk.pop()
            res.append(cur.val)  # 将当前节点的值加入结果列表

            # 移动到右子树
            cur = cur.right

        return res  # 返回中序遍历的结果
```

---

### 代码解释：

1. **初始化栈和指针**：
   - `res` 用于存储中序遍历的结果。
   - `stk` 是一个栈，用于模拟递归过程。
   - `cur` 指向当前节点，从根节点开始。

2. **迭代遍历**：
   - 当栈不为空或 `cur` 不为空时，进入外层循环。

3. **移动到最左子节点**：
   - 通过内层循环，将当前节点及其所有左子节点依次压入栈中，直到找到最左节点。
   - `stk.append(cur)` 将当前节点入栈。
   - `cur = cur.left` 移动到左子节点。

4. **访问节点**：
   - 弹出栈顶节点，即当前的根节点，并将其值加入结果列表。
   - `res.append(cur.val)` 添加节点值到结果列表。

5. **移动到右子树**：
   - `cur = cur.right` 将指针移到右子节点，继续遍历。

6. **返回结果**：
   - 返回中序遍历的结果列表 `res`。

---

### 复杂度分析：

- **时间复杂度**：O(n)，其中 `n` 是树中节点的数量。每个节点最多被访问一次。
- **空间复杂度**：O(H)，其中 `H` 是树的高度。这是栈的最大深度。

---

### 示例分析：

#### 示例：

```python
输入: root = [1, None, 2, 3]
```

树的结构：

```
    1
     \
      2
     /
    3
```

1. **初始状态**：
   - `stk = []`，`res = []`，`cur = root (1)`。

2. **移动到最左子节点**：
   - 将 `1` 入栈，`stk = [1]`。
   - 移动到 `1` 的左子节点（`None`）。

3. **访问节点**：
   - 弹出 `1`，添加到结果：`res = [1]`。
   - 移动到 `1` 的右子节点（`2`）。

4. **继续遍历**：
   - 将 `2` 入栈，`stk = [2]`。
   - 移动到 `2` 的左子节点（`3`）。
   - 将 `3` 入栈，`stk = [2, 3]`。
   - 移动到 `3` 的左子节点（`None`）。

5. **访问节点**：
   - 弹出 `3`，添加到结果：`res = [1, 3]`。
   - 移动到 `3` 的右子节点（`None`）。

6. **访问节点**：
   - 弹出 `2`，添加到结果：`res = [1, 3, 2]`。
   - 移动到 `2` 的右子节点（`None`）。

7. **返回结果**：
   - 最终 `res = [1, 3, 2]`。

---

### 总结：

- 通过使用栈模拟递归过程，我们可以在不使用递归的情况下进行中序遍历。
- 这种方法高效且适用于大型树结构，因为它避免了递归的开销和栈深度限制。
