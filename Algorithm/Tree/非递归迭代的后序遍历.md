### 迭代的后序遍历（非递归）

为了在不使用递归的情况下进行**后序遍历**，我们可以使用**栈**来记录节点的路径，并按后序遍历（即**左-右-根**的顺序）依次访问节点。由于栈是**后进先出**的，因此在实现时需要稍作调整。

#### 代码实现：

```python
from typing import Optional, List

# 定义二叉树节点类
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []  # 如果根节点为空，直接返回空列表

        res = []  # 初始化结果列表
        stk = [root]  # 初始化栈，将根节点入栈

        # 当栈不为空时继续遍历
        while stk:
            cur = stk.pop()  # 弹出栈顶节点
            res.append(cur.val)  # 将当前节点的值添加到结果列表

            # 先将左子节点入栈，再将右子节点入栈
            # 这样确保遍历顺序为 根-右-左
            if cur.left:
                stk.append(cur.left)
            if cur.right:
                stk.append(cur.right)

        # 最后将结果列表反转，得到后序遍历的顺序
        return res[::-1]
```

---

### 代码解释：

1. **初始化栈和结果列表**：
   - 如果根节点为空，直接返回空列表。
   - `res` 用于存储后序遍历的结果。
   - `stk` 是一个栈，初始状态将根节点入栈。

2. **迭代遍历**：
   - 当栈不为空时，循环执行以下操作。

3. **访问当前节点**：
   - 弹出栈顶节点，并将其值添加到结果列表 `res`。

4. **压入子节点**：
   - 先将左子节点压入栈，再将右子节点压入栈。
   - 这样可以确保遍历顺序是**根-右-左**，但我们需要**左-右-根**。

5. **结果反转**：
   - 因此，在最后将结果列表 `res` 反转，以得到正确的后序遍历顺序。

6. **返回结果**：
   - 返回反转后的结果列表 `res[::-1]`。

---

### 复杂度分析：

- **时间复杂度**：O(n)，其中 `n` 是树中节点的数量。每个节点最多被访问一次。
- **空间复杂度**：O(H)，其中 `H` 是树的高度。这是栈的最大深度。

---

### 示例分析：

#### 示例：

```python
输入: root = [1, None, 2, 3]
```

树的结构：

```
    1
     \
      2
     /
    3
```

1. **初始状态**：
   - `stk = [1]`，`res = []`。

2. **访问节点**：
   - 弹出 `1`，添加到结果：`res = [1]`。
   - 将右子节点 `2` 压入栈：`stk = [2]`。

3. **访问节点**：
   - 弹出 `2`，添加到结果：`res = [1, 2]`。
   - 将左子节点 `3` 压入栈：`stk = [3]`。

4. **访问节点**：
   - 弹出 `3`，添加到结果：`res = [1, 2, 3]`。

5. **反转结果**：
   - 最终结果为 `res[::-1] = [3, 2, 1]`。

---

### 总结：

- 通过使用栈模拟递归过程，我们可以在不使用递归的情况下进行后序遍历。
- 为了在栈中实现后序遍历，先按**根-右-左**的顺序遍历，再反转结果，得到正确的**左-右-根**顺序。
- 这种方法避免了递归带来的开销和栈深度限制，并且实现了非递归的后序遍历。
