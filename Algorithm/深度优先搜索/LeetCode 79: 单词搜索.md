### LeetCode 79: 单词搜索

https://leetcode.com/problems/word-search/

---

### 题目描述：

给定一个 `m x n` 的二维字符网格 `board` 和一个字符串 `word`，判断该单词是否存在于网格中。单词可以通过相邻的字符组成，其中“相邻”字符是指在水平方向或垂直方向相邻的单元格。同一个单元格内的字母不允许重复使用。

#### 示例：

```python
输入: board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
], word = "ABCCED"
输出: True
```

在这个例子中，单词 "ABCCED" 存在于网格中。

---

### 解题思路：

该问题可以使用**深度优先搜索 (DFS)** 和**回溯**来解决。我们将从网格中的每个单元格开始，尝试通过相邻单元格找到给定单词。如果找到，则返回 `True`；否则，回溯并继续探索其他路径。

#### 关键步骤：

1. **DFS 函数**：
   - 对于每个单元格，检查它是否与当前字符匹配。
   - 如果匹配，则递归地探索相邻的单元格（上、下、左、右）。
   - 标记单元格为已访问，防止在同一次搜索路径中重复使用。
   - 如果找到了单词，返回 `True`；否则，取消标记并回溯。

2. **从每个单元格开始进行 DFS**：
   - 如果任意一个 DFS 调用返回 `True`，则单词存在于网格中。

---

### 代码实现（附详细注释）：

```python
from typing import List

class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        # 获取网格的行数和列数
        rows, cols = len(board), len(board[0])

        # 辅助函数：从 (r, c) 位置开始进行深度优先搜索
        def dfs(r, c, index):
            # 如果索引等于单词长度，说明单词已找到
            if index == len(word):
                return True
            
            # 检查边界条件和当前单元格是否与单词的当前字符匹配
            if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[index]:
                return False
            
            # 临时标记当前单元格为已访问
            temp = board[r][c]
            board[r][c] = '#'
            
            # 向四个方向（上、下、左、右）进行深度优先搜索
            found = (
                dfs(r + 1, c, index + 1) or  # 下
                dfs(r - 1, c, index + 1) or  # 上
                dfs(r, c + 1, index + 1) or  # 右
                dfs(r, c - 1, index + 1)     # 左
            )
            
            # 恢复当前单元格的原始值（回溯）
            board[r][c] = temp
            
            return found

        # 从网格中的每个单元格开始进行 DFS
        for i in range(rows):
            for j in range(cols):
                if dfs(i, j, 0):  # 如果字符匹配，开始 DFS
                    return True
        
        return False
```

---

### 代码解释：

1. **初始化**：
   - 函数接受二维字符网格 `board` 和字符串 `word` 作为输入。我们使用 `rows` 和 `cols` 来获取网格的行数和列数。

2. **DFS 函数**：
   - 辅助函数 `dfs(r, c, index)` 用于从 `(r, c)` 位置开始查找单词的第 `index` 个字符。
   - 如果 `index` 等于单词的长度，说明单词已找到，返回 `True`。
   - 如果当前单元格越界或与单词的当前字符不匹配，返回 `False`。
   - 临时将当前单元格标记为 `#` 表示已访问，并向四个方向继续递归搜索。
   - 搜索结束后，将单元格恢复为原始值（回溯）。

3. **从每个单元格开始进行 DFS**：
   - 遍历网格中的每个单元格，如果当前单元格字符与单词的第一个字符匹配，则开始 DFS。
   - 如果任意一个 DFS 调用返回 `True`，说明单词存在于网格中。

---

### 复杂度分析：

- **时间复杂度**：O(m * n * 4^L)，其中 `m` 为网格的行数，`n` 为网格的列数，`L` 为单词的长度。在最坏情况下，每个单元格最多向四个方向扩展，导致指数级的时间复杂度。
- **空间复杂度**：O(L)，其中 `L` 为单词的长度。这是递归栈的深度。

---

### 示例分析：

对于输入 `board = [['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']]` 和 `word = "ABCCED"`：

1. 从第一个单元格 `(0, 0)` 开始，发现字符 'A' 匹配。
2. DFS 继续找到 'B'，'C'，'C'，'E'，'D'，与单词完全匹配。
3. 返回 `True`。

---

### 总结：

该解法使用了深度优先搜索和回溯方法来探索网格中的可能路径，并在不满足条件时进行回溯。通过回溯，我们可以确保每个单元格在同一次搜索路径中只被访问一次，从而避免重复使用同一单元格。尽管该解法的时间复杂度较高，但它能够在合理的时间内解决网格搜索问题。
