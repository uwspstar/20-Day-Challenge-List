### LeetCode 875: [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)

---

### 题目描述：

Koko 喜欢吃香蕉。有一堆香蕉堆成的数组 `piles`，其中每个值表示这一堆香蕉的数量。Koko 有一只非常能干的猴子，但她只能在一个小时内吃完一堆香蕉。Koko 希望在 `h` 小时内吃完所有的香蕉。每小时她可以吃掉一堆香蕉，但最多吃 `k` 个。如果这一小时内吃不完一堆香蕉，那堆香蕉会留到下一小时继续吃。

现在你需要求出 Koko 吃完所有香蕉的最小速度 `k`（即她每小时能吃掉的最少香蕉数）。

---

### 示例：

#### 示例 1:
```
输入: piles = [3,6,7,11], h = 8
输出: 4
```

#### 示例 2:
```
输入: piles = [30,11,23,4,20], h = 5
输出: 30
```

#### 示例 3:
```
输入: piles = [30,11,23,4,20], h = 6
输出: 23
```

---

### 解题思路：

这道题的核心问题是如何找到 Koko 吃香蕉的最小速度 `k`，使得她在 `h` 小时内可以吃完所有的香蕉。可以通过二分查找来解决这个问题。

1. **二分查找的边界**：
   - 最小的速度 `k` 应该是 1，因为 Koko 至少要每小时吃 1 根香蕉。
   - 最大的速度 `k` 应该是所有堆中最大的香蕉数量（`max(piles)`），因为最快的情况是每小时吃掉一整堆香蕉。

2. **如何判断是否可以在 `h` 小时内吃完**：
   - 给定一个吃香蕉的速度 `k`，我们可以遍历每一堆香蕉，计算吃完这堆香蕉需要的小时数。
   - 如果总的小时数小于或等于 `h`，说明这个速度 `k` 是可行的。

3. **步骤**：
   - 通过二分查找缩小速度 `k` 的范围，每次取中间值 `mid`，判断是否在 `h` 小时内吃完所有香蕉。
   - 如果可以在 `h` 小时内吃完，则尝试更小的速度；否则增加速度。

---

### 代码实现：

```python
from typing import List
import math

class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        # 设置二分查找的左右边界
        left, right = 1, max(piles)
        # 最终答案
        ans = right
        
        while left <= right:
            mid = (left + right) // 2
            total_hours = 0
            
            # 计算以当前速度 mid 吃完所有香蕉需要的小时数
            for pile in piles:
                total_hours += math.ceil(pile / mid)
            
            # 如果在 h 小时内可以吃完，则速度是可行的，尝试更小的速度
            if total_hours <= h:
                ans = mid
                right = mid - 1
            # 否则，说明速度太慢，增加速度
            else:
                left = mid + 1
        
        return ans
```

---

### 代码解释：

1. **初始化**：
   - 设置二分查找的左右边界，`left = 1`，表示最小吃香蕉的速度；`right = max(piles)`，表示最大速度为吃掉最大的那堆香蕉的数量。

2. **计算总小时数**：
   - 遍历 `piles` 中的每一堆香蕉，计算以速度 `mid` 吃掉该堆香蕉所需的小时数。每次计算时，使用 `math.ceil(pile / mid)`，即每小时吃 `mid` 根香蕉，可能会有剩余部分需要再花一个小时。

3. **调整二分边界**：
   - 如果当前速度 `mid` 可以在 `h` 小时内吃完所有香蕉，则记录当前的速度 `mid` 为答案，并继续尝试更小的速度，因此将 `right` 调整为 `mid - 1`。
   - 如果不能在 `h` 小时内吃完，则速度太慢，需要增加速度，调整 `left` 为 `mid + 1`。

---

### 复杂度分析：

- **时间复杂度**：O(n log m)，其中 `n` 是香蕉堆的数量，`m` 是香蕉的最大数量。二分查找的时间复杂度为 O(log m)，每次需要遍历所有的 `n` 堆香蕉。
- **空间复杂度**：O(1)，只使用了常量空间。

---

### 总结：

该题通过二分查找的方式找到 Koko 吃香蕉的最小速度。在每次确定速度后，计算吃完所有香蕉所需的小时数，并通过调整左右边界逐步缩小范围，最终找到满足条件的最小速度。
