### LeetCode 153: Find Minimum in Rotated Sorted Array（寻找旋转排序数组中的最小值）

---

**Key Tips 旋转排序数组: # if mid <= last element, then belongs to lower half**

---

https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/

**题目描述**：
假设按照升序排序的数组在某个未知的点上进行了旋转（例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]`）。请找出旋转排序数组中的最小元素。假设数组中不存在重复元素。

**代码实现**：
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 初始化左右指针
        l, r = 0, len(nums) - 1
        idx = -1  # 用于存储最小值的索引
        
        # 二分查找最小值
        while l <= r:
            mid = (l + r) // 2
            # 如果 mid 处的值小于等于数组最后一个值，说明最小值在左半部分
            if nums[mid] <= nums[-1]:
                idx = mid  # 更新最小值索引
                r = mid - 1
            else:
                # 否则，最小值在右半部分
                l = mid + 1
        
        # 返回最小值
        return nums[idx]

# 时间复杂度：O(log n) - 二分查找的时间复杂度
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**题目分析**：
旋转排序数组在某个未知的点上进行了旋转，但整体仍保持部分有序。因此，我们可以利用数组的有序性质，使用二分查找的方法来找到最小值。通过比较中间值 `nums[mid]` 和数组最后一个元素 `nums[-1]`，我们可以判断当前中间值位于旋转后的哪一部分，从而逐步缩小查找范围。

**解决方案详解**：

- **初始化条件**：
  - 左边界 `l` 初始化为 0，右边界 `r` 初始化为 `len(nums) - 1`，表示整个数组。
  - 使用变量 `idx` 记录最小值的索引。

- **二分查找的过程**：
  - 每次计算中间值 `mid`，并与数组最后一个元素 `nums[-1]` 进行比较：
    - 如果 `nums[mid] <= nums[-1]`，说明 `mid` 位于旋转后的最小值部分，将 `idx` 更新为 `mid`，并将右边界 `r` 移动到 `mid - 1`。
    - 如果 `nums[mid] > nums[-1]`，说明最小值在 `mid` 右侧，将左边界 `l` 移动到 `mid + 1`。
  
- **结束条件**：
  - 当左右指针交错时，循环结束，此时 `idx` 指向数组的最小值。

**复杂度分析**：
- **时间复杂度**：O(log n)，因为我们使用了二分查找，每次将搜索范围缩小一半。
- **空间复杂度**：O(1)，只使用了常量空间来存储指针和中间变量。

**示例讲解**：

#### 示例 1:
```
输入: nums = [3,4,5,1,2]
```
- 初始状态：`l = 0`, `r = 4`，`nums[-1] = 2`。
- 第一次迭代：`mid = (0 + 4) // 2 = 2`，`nums[2] = 5 > 2`，更新左指针：`l = 3`。
- 第二次迭代：`mid = (3 + 4) // 2 = 3`，`nums[3] = 1 <= 2`，更新最小值索引 `idx = 3`，更新右指针：`r = 2`。
- 循环结束，返回 `nums[3] = 1`。

#### 示例 2:
```
输入: nums = [4,5,6,7,0,1,2]
```
- 初始状态：`l = 0`, `r = 6`，`nums[-1] = 2`。
- 第一次迭代：`mid = (0 + 6) // 2 = 3`，`nums[3] = 7 > 2`，更新左指针：`l = 4`。
- 第二次迭代：`mid = (4 + 6) // 2 = 5`，`nums[5] = 1 <= 2`，更新最小值索引 `idx = 5`，更新右指针：`r = 4`。
- 第三次迭代：`mid = (4 + 4) // 2 = 4`，`nums[4] = 0 <= 2`，更新最小值索引 `idx = 4`，更新右指针：`r = 3`。
- 循环结束，返回 `nums[4] = 0`。

**总结**：
二分查找是寻找旋转排序数组最小值的高效方法，能够在 O(log n) 的时间复杂度下解决问题。
