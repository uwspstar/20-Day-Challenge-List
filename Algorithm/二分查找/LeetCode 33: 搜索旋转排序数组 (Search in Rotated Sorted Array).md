### LeetCode 33: 搜索旋转排序数组 (Search in Rotated Sorted Array)

---

**Key Tips 旋转排序数组: # if mid <= last element, then belongs to lower half**

---


https://leetcode.com/problems/search-in-rotated-sorted-array/description/

**题目描述**：
给定一个已按照升序排列的整数数组 `nums`，但是该数组在某个未知的点上进行了旋转。例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]`。请你在数组中搜索给定的目标值 `target`，如果目标值存在于数组中，返回它的索引；否则，返回 `-1`。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

### 示例 1:

```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```

### 示例 2:

```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

### 示例 3:

```
输入: nums = [1], target = 0
输出: -1
```

---

## 解题思路

这是一个旋转排序数组的搜索问题，要求我们使用**二分查找**在 O(log n) 的时间复杂度内找到目标值的位置。

旋转后的数组可以分为两部分，其中至少一部分是有序的。我们可以根据有序部分的特性来确定目标值是在左半部分还是右半部分。

### 关键步骤：

1. **判断哪部分是有序的**：
   - 如果 `nums[mid] >= nums[l]`，则左半部分有序。
   - 否则右半部分有序。

2. **利用有序部分**：
   - 在左半部分有序时，判断 `target` 是否在 `nums[l]` 和 `nums[mid]` 之间，进而确定移动 `l` 还是 `r`。
   - 在右半部分有序时，判断 `target` 是否在 `nums[mid]` 和 `nums[r]` 之间，进而移动指针。

3. **重复二分查找**直到找到目标值或者指针 `l` 超过 `r`。

---

### 代码实现：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            mid = (l + r) // 2
            
            # 如果找到了目标值，直接返回其索引
            if nums[mid] == target:
                return mid
            
            # 判断左半部分是否有序
            if nums[mid] >= nums[l]:
                # 如果目标值在左半部分，移动右指针
                if nums[l] <= target < nums[mid]:
                    r = mid - 1
                else:
                    l = mid + 1
            # 否则右半部分有序
            else:
                # 如果目标值在右半部分，移动左指针
                if nums[mid] < target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid - 1
        return -1
```

---

### 代码解释：

1. **初始化指针**：
   - `l` 指向数组的第一个元素，`r` 指向数组的最后一个元素。

2. **二分查找的核心**：
   - 计算中间点 `mid`，并检查 `nums[mid]` 是否等于 `target`，如果找到就返回 `mid`。
   - 接着，我们判断哪一部分（左边还是右边）是有序的：
     - 如果 `nums[mid] >= nums[l]`，则左半部分是有序的。
     - 如果 `nums[mid] < nums[l]`，则右半部分是有序的。
   - 在有序部分中，进一步判断目标值是否在该部分范围内，进而决定移动左指针还是右指针。

3. **循环结束条件**：
   - 当 `l > r` 时，说明目标值不在数组中，返回 `-1`。

---

### 复杂度分析：

- **时间复杂度**：O(log n)，因为我们使用了二分查找，每次将搜索空间缩小一半。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间来存储指针。

---

### 示例讲解：

#### 示例 1:

```
输入: nums = [4,5,6,7,0,1,2], target = 0
```

- 第一次迭代：`mid = (0 + 6) // 2 = 3`，`nums[3] = 7`。
  - 左半部分 `[4,5,6,7]` 有序，`target = 0` 不在该范围内，因此移动左指针：`l = 4`。

- 第二次迭代：`mid = (4 + 6) // 2 = 5`，`nums[5] = 1`。
  - 右半部分 `[0,1,2]` 有序，`target = 0` 在该范围内，因此移动右指针：`r = 4`。

- 第三次迭代：`mid = (4 + 4) // 2 = 4`，`nums[4] = 0`，找到了目标值，返回 `4`。

#### 示例 2:

```
输入: nums = [4,5,6,7,0,1,2], target = 3
```

- 第一次迭代：`mid = (0 + 6) // 2 = 3`，`nums[3] = 7`。
  - 左半部分 `[4,5,6,7]` 有序，`target = 3` 不在该范围内，移动左指针：`l = 4`。

- 第二次迭代：`mid = (4 + 6) // 2 = 5`，`nums[5] = 1`。
  - 右半部分 `[0,1,2]` 有序，`target = 3` 不在该范围内，移动右指针：`r = 4`。

- 第三次迭代：`mid = (4 + 4) // 2 = 4`，`nums[4] = 0`，未找到目标值，返回 `-1`。

---

### 总结：

通过二分查找，结合旋转排序数组的性质，可以在 O(log n) 的时间复杂度内高效地找到目标值的索引。关键在于判断哪一半是有序的，然后根据有序部分确定是否在该区间内继续查找。

---

### 你可以在代码中使用 `if nums[mid] <= nums[-1]:` 吗？

是的，你**可以使用** `if nums[mid] <= nums[-1]:`，并且它能够正常工作。让我解释一下它的工作原理以及为什么可以使用 `nums[-1]`。

### 为什么 `if nums[mid] <= nums[-1]` 能够工作？

在旋转排序数组中，**总有一部分是有序的**，要么是左半部分，要么是右半部分。通过检查中间元素 `nums[mid]` 是否小于等于数组的最后一个元素 `nums[-1]`，你可以判断**右半部分**（从 `mid` 到 `r`）是否是有序的。

### 解释：
- **如果 `nums[mid] <= nums[-1]`**：
  - 这意味着数组的**右半部分**（从 `mid` 到 `r`）是有序的。如果目标值在这个有序范围内（即 `target` 在 `nums[mid]` 和 `nums[r]` 之间），你应该移动左指针到 `mid + 1`，在右半部分继续搜索。否则，你应该移动右指针到 `mid - 1`，在左半部分搜索。
  
- **如果 `nums[mid] > nums[-1]`**：
  - 这意味着数组的**左半部分**（从 `l` 到 `mid`）是有序的。如果目标值在这个有序范围内（即 `target` 在 `nums[l]` 和 `nums[mid]` 之间），你应该移动右指针到 `mid - 1`，在左半部分继续搜索。否则，你应该移动左指针到 `mid + 1`，在右半部分搜索。

### 使用 `nums[-1]` 的修改代码：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            mid = (l + r) // 2
            if nums[mid] == target:
                return mid
            
            # 通过与最后一个元素比较，检查右半部分是否有序
            if nums[mid] <= nums[-1]:
                # 如果目标值在有序的右半部分，继续在右边查找
                if nums[mid] <= target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid - 1
            else:
                # 如果目标值在有序的左半部分，继续在左边查找
                if nums[l] <= target < nums[mid]:
                    r = mid - 1
                else:
                    l = mid + 1
        return -1
```

### 为什么这个方法可行？

- **检查 `nums[mid] <= nums[-1]`**：这用于检查数组的右半部分是否有序。如果是有序的，你可以在右半部分继续搜索。
- **使用 `nums[-1]`**：`nums[-1]` 是数组的最后一个元素，它提供了一个参考点，用来判断右半部分是否有序。

### 总结：
- 是的，你可以在代码中使用 `if nums[mid] <= nums[-1]`。这是一个有效的条件，可以用来判断数组的右半部分是否有序。
- 这种方法有效的原因是，在旋转排序数组中，总有一部分是有序的，你可以利用有序部分来减少搜索范围。
- 该算法的时间复杂度仍然是 O(log n)，因为它仍然使用了二分查找。
  
