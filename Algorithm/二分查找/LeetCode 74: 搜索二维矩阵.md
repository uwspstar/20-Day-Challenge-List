**LeetCode 74: 搜索二维矩阵 (Search a 2D Matrix)**

**题目描述**：  
给定一个 `m x n` 的二维矩阵 `matrix`，其中每行的整数从左到右按升序排列，并且每行的第一个整数大于前一行的最后一个整数。编写一个高效算法来判断目标值 `target` 是否存在于矩阵中。

[LeetCode 74: Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)

---

### 解题思路

由于矩阵中的每一行和每一列都是升序的，我们可以将整个二维矩阵视为一个长度为 `m * n` 的一维数组，从而使用二分查找来高效地查找目标值。这样可以避免直接遍历每一行和每一列。

1. **将二维矩阵转换为一维数组**：
   - 将矩阵的行和列坐标 `(row, col)` 映射为一维索引 `m`：
     - `m = row * cols + col`
   - 同样地，可以将一维索引 `m` 反向映射为二维坐标 `(row, col)`：
     - `row = m // cols`
     - `col = m % cols`

2. **使用二分查找**：
   - 设定一维数组的左右指针 `l` 和 `r`。
   - 计算中间索引 `m`，然后将 `m` 映射为矩阵中的 `(row, col)` 坐标，获取相应的矩阵元素。
   - 根据目标值 `target` 与当前元素的大小关系调整左右指针。

---

### 代码实现

```python
from typing import List

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        # 获取矩阵的行数和列数
        rows, cols = len(matrix), len(matrix[0])
        
        # 将二维矩阵展开成一维进行二分查找，定义左右边界
        l, r = 0, rows * cols - 1
        
        # 进行二分查找
        while l <= r:
            # 计算中间索引
            m = l + (r - l) // 2
            # 将一维索引 m 映射回二维矩阵中的行和列
            row, col = m // cols, m % cols
            # 获取当前元素并与目标值进行比较
            if target > matrix[row][col]:
                # 如果目标值大于当前元素，移动左边界
                l = m + 1
            elif target < matrix[row][col]:
                # 如果目标值小于当前元素，移动右边界
                r = m - 1
            else:
                # 找到目标值，返回 True
                return True
        
        # 如果查找完成且未找到目标值，返回 False
        return False
```

---

### 示例解析

假设输入 `matrix = [[1, 3, 5], [7, 10, 11], [13, 15, 20]]`，`target = 10`，我们将逐步运行代码并解释：

1. **初始化**：
   - 行数 `rows = 3`，列数 `cols = 3`，所以总元素数为 `rows * cols = 9`。
   - 左指针 `l = 0`，右指针 `r = 8`（从 `0` 到 `8`）。

2. **第一次二分查找**：
   - 计算中间索引：`m = 0 + (8 - 0) // 2 = 4`
   - 将 `m = 4` 转换为二维索引 `(row, col)`：
     - `row = m // cols = 4 // 3 = 1`（表示第 2 行）
     - `col = m % cols = 4 % 3 = 1`（表示第 2 列）
   - 获取 `matrix[1][1] = 10`

3. **比较并调整指针**：
   - `matrix[1][1] == target`，找到目标值 `10`，返回 `True`。

---

### 映射公式解释

在代码中，我们使用了以下公式将一维索引 `m` 转换为矩阵中的行列索引：

```python
row, col = m // cols, m % cols
```

- `row = m // cols`：表示行索引，这是通过整数除法来获得的，`m` 表示在矩阵展开后的一维索引，`cols` 表示列数。通过将 `m` 除以列数，我们可以得到该索引所在的行数。
- `col = m % cols`：表示列索引，这是通过取余数获得的。在第 `m` 个位置上，它在该行的具体位置可以通过 `cols` 来确定。

例如：  
- 如果 `m = 4`，`cols = 3`，则：
  - `row = 4 // 3 = 1`，表示第 2 行
  - `col = 4 % 3 = 1`，表示第 2 列
- 所以 `matrix[1][1]` 表示矩阵中的值 `10`。

---

### 复杂度分析

- **时间复杂度**：O(log(m * n))，因为我们使用二分查找算法。
- **空间复杂度**：O(1)，只用了常量空间。

---

### 总结

此方法利用了矩阵的有序特性，将矩阵视为一维数组并使用二分查找，显著提高了搜索效率。关键在于理解如何通过 `m // cols` 和 `m % cols` 将一维索引映射为二维坐标，最终实现快速定位目标值。
