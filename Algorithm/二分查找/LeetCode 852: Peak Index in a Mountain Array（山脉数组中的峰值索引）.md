### LeetCode 852: Peak Index in a Mountain Array（山脉数组中的峰值索引）

**题目描述**：
给定一个山脉数组 `arr`，找到山峰（即数组中最大元素）的索引。山脉数组满足以下条件：`arr[0] < arr[1] < ... < arr[i-1] < arr[i] > arr[i+1] > ... > arr[arr.length - 1]`。

**代码实现**：
```python
class Solution:
    def peakIndexInMountainArray(self, arr: List[int]) -> int:
        # 初始化左右指针
        l, r = 0, len(arr) - 1
        idx = -1  # 用于存储峰值的索引
        
        # 二分查找峰值
        while l <= r:
            mid = (l + r) // 2
            # 如果中间值大于其右侧值，说明峰值在或靠近左侧
            if arr[mid] > arr[mid + 1]:
                idx = mid  # 更新峰值索引
                r = mid - 1
            else:
                # 否则，峰值在右侧
                l = mid + 1
        
        # 返回峰值的索引
        return idx

# 时间复杂度：O(log n) - 二分查找的时间复杂度
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**题目分析**：
题目要求找到山脉数组中的峰值索引。山脉数组的特性是，前半部分单调递增，后半部分单调递减。因此，我们可以通过二分查找来解决这个问题。

**解决方案详解**：

- **初始化条件**：
  - 左边界 `l` 初始化为 0，右边界 `r` 初始化为 `len(arr) - 1`，用于查找整个数组的峰值。
  - 使用变量 `idx` 记录峰值的索引。

- **二分查找的过程**：
  - 每次计算中间值 `mid`，比较 `arr[mid]` 和 `arr[mid + 1]`：
    - 如果 `arr[mid] > arr[mid + 1]`，说明 `mid` 处可能是峰值，更新 `idx` 为 `mid`，并将右边界 `r` 移动到 `mid - 1`。
    - 如果 `arr[mid] < arr[mid + 1]`，说明峰值在右侧，移动左边界 `l` 到 `mid + 1`。
  
- **结束条件**：
  - 当左右指针交错时，循环结束，此时 `idx` 指向数组的峰值。

**复杂度分析**：
- **时间复杂度**：O(log n)，我们使用了二分查找，每次迭代将搜索范围缩小一半。
- **空间复杂度**：O(1)，只使用了常量空间来存储指针和中间变量。

**示例讲解**：

#### 示例 1:
```
输入: arr = [0,1,0]
```
- 初始状态：`l = 0`, `r = 2`。
- 第一次迭代：`mid = (0 + 2) // 2 = 1`，`arr[1] = 1 > arr[2] = 0`，峰值可能为 `1`，更新右指针：`r = 0`。
- 循环结束，返回 `idx = 1`。

#### 示例 2:
```
输入: arr = [0,2,1,0]
```
- 初始状态：`l = 0`, `r = 3`。
- 第一次迭代：`mid = (0 + 3) // 2 = 1`，`arr[1] = 2 > arr[2] = 1`，更新峰值索引 `idx = 1`，右指针移动到 `r = 0`。
- 循环结束，返回 `idx = 1`。

**总结**：
通过二分查找方法，可以高效地找到山脉数组中的峰值索引，时间复杂度为 O(log n)，空间复杂度为 O(1)。这种方法适用于具有单调递增和单调递减特性的数组。
