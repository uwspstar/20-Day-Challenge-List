### LeetCode 875: Koko Eating Bananas（珂珂吃香蕉问题）

https://leetcode.com/problems/koko-eating-bananas/description/

**题目描述**：
珂珂喜欢吃香蕉。她有一堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫已经离开，并将在 `h` 小时后回来。珂珂可以以每小时 `k` 根香蕉的速度吃完香蕉。如果她吃完一堆香蕉需要超过一小时，她将会在下一个小时继续吃这一堆，直到吃完为止。请你计算出珂珂可以在 `h` 小时内吃完所有香蕉的最小速度 `k`。

**代码实现**：
```python
import math

class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        # 定义最小速度为1，最大速度为香蕉堆中最多的香蕉数量
        l, r = 1, max(piles)
        ans = r  # 初始化结果为最大速度
        
        # 开始二分查找最小吃香蕉速度
        while l <= r:
            mid = (l + r) // 2  # 当前假设的吃香蕉速度
            total_hrs = 0  # 记录总共需要的小时数
            
            # 计算以当前速度吃完所有香蕉所需的时间
            for pile in piles:
                total_hrs += math.ceil(pile / mid)  # 需要上取整
            
            # 如果在 h 小时内能吃完所有香蕉，更新答案并缩小右边界
            if total_hrs <= h:
                ans = mid
                r = mid - 1
            else:
                # 如果时间超过 h 小时，增加吃香蕉的速度
                l = mid + 1 
        
        return ans

# 时间复杂度：O(n log m)，其中 n 是香蕉堆的数量，m 是最大堆的香蕉数量，二分查找的复杂度为 O(log m)，每次迭代需要遍历所有香蕉堆计算总时间 O(n)。
# 空间复杂度：O(1)，只使用了常量空间来存储变量。
```

**题目分析**：
我们需要在 `h` 小时内吃完所有的香蕉，目标是找到珂珂吃香蕉的最小速度 `k`。这类问题可以使用二分查找来高效解决。我们通过假设珂珂以不同速度 `k` 吃香蕉，逐步缩小速度的范围，直到找到最小满足条件的速度。

**解决方案详解**：

- **初始化条件**：
  - 左边界 `l` 表示最小速度（至少是1根香蕉/小时）。
  - 右边界 `r` 表示最大速度（为香蕉堆中最多的那堆的数量，因为速度最多只能为最大堆的数量，即一次性吃完所有香蕉）。
  - 使用变量 `ans` 来存储最终的最小速度。

- **二分查找的过程**：
  - 每次取中间值 `mid`，代表当前假设的吃香蕉速度。
  - 遍历每堆香蕉，计算以当前速度 `mid` 吃完每堆香蕉所需的时间，使用 `math.ceil(pile / mid)` 来计算吃完一堆香蕉的小时数，并累加到 `total_hrs`。
  - 如果 `total_hrs` 小于等于 `h`，说明当前速度足够，可以尝试更小的速度（缩小右边界 `r`）。
  - 如果 `total_hrs` 大于 `h`，说明当前速度不足，需要提高速度（增大左边界 `l`）。

- **结束条件**：
  - 当左右指针交错时，循环结束，`ans` 中存储的就是珂珂可以在 `h` 小时内吃完所有香蕉的最小速度。

**复杂度分析**：
- **时间复杂度**：O(n log m)，其中 n 是香蕉堆的数量，m 是最大堆的香蕉数量。二分查找需要 O(log m) 次迭代，每次迭代需要 O(n) 的时间来计算吃完所有香蕉的时间。
- **空间复杂度**：O(1)，只使用了常量空间存储指针和中间变量。

**示例讲解**：

#### 示例 1:
```
输入: piles = [3,6,7,11], h = 8
```
- 初始状态：`l = 1`, `r = 11`。
- 第一次迭代：`mid = (1 + 11) // 2 = 6`，计算 `total_hrs`，分别为 `math.ceil(3/6) + math.ceil(6/6) + math.ceil(7/6) + math.ceil(11/6) = 1 + 1 + 2 + 2 = 6` 小时，满足条件，更新 `ans = 6`，并缩小右边界 `r = 5`。
- 第二次迭代：`mid = (1 + 5) // 2 = 3`，计算 `total_hrs`，分别为 `math.ceil(3/3) + math.ceil(6/3) + math.ceil(7/3) + math.ceil(11/3) = 1 + 2 + 3 + 4 = 10` 小时，超过了 `h`，增加速度，更新左边界 `l = 4`。
- 第三次迭代：`mid = (4 + 5) // 2 = 4`，计算 `total_hrs`，分别为 `math.ceil(3/4) + math.ceil(6/4) + math.ceil(7/4) + math.ceil(11/4) = 1 + 2 + 2 + 3 = 8` 小时，满足条件，更新 `ans = 4`，缩小右边界 `r = 3`。
- 最终结果为 `ans = 4`。

#### 示例 2:
```
输入: piles = [30,11,23,4,20], h = 5
```
- 初始状态：`l = 1`, `r = 30`。
- 二分查找多次迭代后，结果为 `ans = 30`，因为珂珂必须每小时吃掉最多的香蕉以满足 5 小时的限制。

**总结**：
通过二分查找，可以高效找到珂珂在规定时间内吃完香蕉的最小速度，时间复杂度为 O(n log m)，适合处理具有单调性特性的优化问题。
