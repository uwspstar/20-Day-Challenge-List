### LeetCode 704: Binary Search（二分查找）

**题目描述**：
给定一个排序好的整数数组 `nums` 和一个目标值 `target`，请你在数组中查找目标值。如果目标值存在，返回它的索引。如果目标值不存在，则返回 `-1`。

**代码实现**：
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # 初始化左右指针
        l, r = 0, len(nums) - 1
        
        # 开始二分查找
        while l <= r:
            mid = (l + r) // 2
            # 找到目标值，返回索引
            if nums[mid] == target:
                return mid
            # 如果中间值大于目标值，目标值在左侧
            elif nums[mid] > target:
                r = mid - 1
            # 如果中间值小于目标值，目标值在右侧
            else:
                l = mid + 1
        
        # 未找到目标值，返回 -1
        return -1

# 时间复杂度：O(log n) - 二分查找的时间复杂度
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**题目分析**：
该问题属于经典的二分查找问题。给定一个升序排列的数组，通过二分查找可以快速定位目标值 `target`。我们在每次迭代中，将搜索范围缩小为原来的一半，直到找到目标值或者搜索范围为空。

**解决方案详解**：

- **初始化条件**：
  - 左边界 `l` 初始化为 0，右边界 `r` 初始化为 `len(nums) - 1`。
  
- **二分查找的过程**：
  - 通过计算中间值 `mid`，比较 `nums[mid]` 和 `target`：
    - 如果 `nums[mid] == target`，则直接返回 `mid`。
    - 如果 `nums[mid] > target`，则将右边界 `r` 移动到 `mid - 1`，表示目标值在左侧。
    - 如果 `nums[mid] < target`，则将左边界 `l` 移动到 `mid + 1`，表示目标值在右侧。
  
- **结束条件**：
  - 当左边界超过右边界时，说明数组中不存在目标值，返回 `-1`。

**复杂度分析**：
- **时间复杂度**：O(log n)，每次迭代将搜索范围缩小一半，因此时间复杂度为 O(log n)。
- **空间复杂度**：O(1)，只使用了常量空间存储指针和中间变量。

**示例讲解**：

#### 示例 1:
```
输入: nums = [-1,0,3,5,9,12], target = 9
```
- 初始状态：`l = 0`, `r = 5`，计算 `mid = (0 + 5) // 2 = 2`，`nums[2] = 3 < 9`，更新左指针：`l = 3`。
- 第二次迭代：`mid = (3 + 5) // 2 = 4`，`nums[4] = 9 == 9`，找到目标值，返回 `4`。

#### 示例 2:
```
输入: nums = [-1,0,3,5,9,12], target = 2
```
- 初始状态：`l = 0`, `r = 5`，计算 `mid = (0 + 5) // 2 = 2`，`nums[2] = 3 > 2`，更新右指针：`r = 1`。
- 第二次迭代：`mid = (0 + 1) // 2 = 0`，`nums[0] = -1 < 2`，更新左指针：`l = 1`。
- 第三次迭代：`mid = (1 + 1) // 2 = 1`，`nums[1] = 0 < 2`，更新左指针：`l = 2`。
- 此时 `l = 2 > r = 1`，搜索结束，返回 `-1`。

**总结**：
二分查找是处理有序数组中查找问题的高效算法，时间复杂度为 O(log n)，适用于查找操作频繁的场景。
