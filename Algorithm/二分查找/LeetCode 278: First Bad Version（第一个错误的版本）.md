### LeetCode 278: First Bad Version（第一个错误的版本）

https://leetcode.com/problems/first-bad-version/

**题目描述**：
你是产品经理，目前正在带领一个团队开发一个新产品。然而，某一天你发现产品的某个版本存在问题，导致后续的所有版本都出错。假设你有 `n` 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误版本。你可以通过调用 `isBadVersion(version)` API 来判断版本是否出错。请你实现一个函数来查找第一个错误的版本。

你应该尽量减少对 `isBadVersion` API 的调用次数。

**代码实现**：
```python
# The isBadVersion API is already defined for you.
# def isBadVersion(version: int) -> bool:

class Solution:
    def firstBadVersion(self, n: int) -> int:
        # 初始化左右指针
        l, r = 1, n
        idx = -1  # 用于记录第一个错误版本的索引
        
        # 二分查找第一个错误版本
        while l <= r:
            mid = (l + r) // 2
            # 如果当前版本是错误版本，可能是第一个错误版本
            if isBadVersion(mid):
                idx = mid  # 更新第一个错误版本的索引
                r = mid - 1  # 错误版本可能在左侧
            else:
                # 如果当前版本是正确的，错误版本在右侧
                l = mid + 1
        
        # 返回第一个错误版本的索引
        return idx

# 时间复杂度：O(log n) - 二分查找的时间复杂度
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**题目分析**：
该问题可以使用二分查找来高效解决。因为版本数组是有序的，从某个版本开始都是错误版本，因此我们可以利用二分查找缩小查找范围，直到找到第一个错误的版本。

**解决方案详解**：

- **初始化条件**：
  - 左边界 `l` 初始化为 1，右边界 `r` 初始化为 `n`，即所有版本的范围。
  - 使用 `idx` 记录第一个错误版本的索引。

- **二分查找的过程**：
  - 每次计算中间值 `mid`，调用 `isBadVersion(mid)`：
    - 如果 `isBadVersion(mid)` 返回 `True`，说明当前版本以及之后的版本都是错误的，可能第一个错误版本在左侧，因此将右边界 `r` 移动到 `mid - 1`，同时更新 `idx` 为 `mid`。
    - 如果 `isBadVersion(mid)` 返回 `False`，说明当前版本是正确的，错误版本在右侧，因此将左边界 `l` 移动到 `mid + 1`。

- **结束条件**：
  - 当左右指针交错时，循环结束，`idx` 就是第一个错误版本的索引。

**复杂度分析**：
- **时间复杂度**：O(log n)，我们每次迭代都将查找范围缩小一半，因此时间复杂度为 O(log n)。
- **空间复杂度**：O(1)，只使用了常量空间来存储指针和中间变量。

**示例讲解**：

#### 示例 1:
```
输入: n = 5, bad = 4
```
- 初始状态：`l = 1`, `r = 5`。
- 第一次迭代：`mid = (1 + 5) // 2 = 3`，`isBadVersion(3) = False`，更新左指针：`l = 4`。
- 第二次迭代：`mid = (4 + 5) // 2 = 4`，`isBadVersion(4) = True`，更新第一个错误版本索引 `idx = 4`，右指针移动到 `r = 3`。
- 循环结束，返回 `idx = 4`。

#### 示例 2:
```
输入: n = 1, bad = 1
```
- 初始状态：`l = 1`, `r = 1`。
- 第一次迭代：`mid = (1 + 1) // 2 = 1`，`isBadVersion(1) = True`，更新第一个错误版本索引 `idx = 1`，右指针移动到 `r = 0`。
- 循环结束，返回 `idx = 1`。

**总结**：
该问题通过二分查找能够高效解决，时间复杂度为 O(log n)，适用于查找排序数组中的目标值或特定条件问题。
