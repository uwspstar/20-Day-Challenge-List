### **题目：柱状图中最大的矩形面积 (Largest Rectangle in Histogram)**

---

### **代码实现**：
```python
from typing import List

class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        maxArea = 0
        stack = []  # 栈存储元组：(柱子的起始索引, 柱子高度)

        # 遍历柱子的索引和高度
        for i, h in enumerate(heights):
            start = i
            # 当栈不为空且当前柱子的高度小于栈顶柱子的高度
            while stack and stack[-1][1] > h:
                index, height = stack.pop()
                # 计算以弹出柱子为高的矩形面积
                maxArea = max(maxArea, height * (i - index))
                start = index  # 更新起始索引
            stack.append((start, h))  # 将当前柱子加入栈

        # 遍历栈中剩余的柱子
        for i, h in stack:
            maxArea = max(maxArea, h * (len(heights) - i))  # 计算剩余柱子的最大面积
        
        return maxArea
```

---

### **算法解析：**

#### **栈的作用**：
- 使用单调递增栈保存柱子的起始索引和高度。
- 当遍历到一个较短柱子时，计算并弹出较高柱子的面积，确保栈中柱子的高度保持递增顺序。

#### **核心思想**：
1. 每当柱子高度下降时，意味着以栈中柱子为高的矩形结束。
2. 将当前柱子视为新的起点，并更新起始索引。

---

### **时间和空间复杂度分析**：

#### **时间复杂度**：
- 每个柱子最多入栈一次、出栈一次，总操作次数为 \(O(n)\)。
- 因此，总时间复杂度为 **\(O(n)\)**。

#### **空间复杂度**：
- 栈的空间消耗取决于柱子的数量，最坏情况下为 \(O(n)\)。
- 因此，总空间复杂度为 **\(O(n)\)**。

---

### **示例运行步骤**：

#### **输入**：
```python
heights = [2, 1, 5, 6, 2, 3]
```

#### **步骤**：

1. 初始化：
   - `maxArea = 0`
   - `stack = []`

2. 遍历柱子：
   - **柱子 1**: 高度 `2`：
     - 栈为空，直接入栈：`stack = [(0, 2)]`
   - **柱子 2**: 高度 `1`：
     - 栈顶高度 `2 > 1`，弹出 `(0, 2)`，计算面积：`maxArea = 2 * (1 - 0) = 2`
     - 更新起点索引：`start = 0`
     - 入栈：`stack = [(0, 1)]`
   - **柱子 3**: 高度 `5`：
     - 栈顶高度 `1 < 5`，直接入栈：`stack = [(0, 1), (2, 5)]`
   - **柱子 4**: 高度 `6`：
     - 栈顶高度 `5 < 6`，直接入栈：`stack = [(0, 1), (2, 5), (3, 6)]`
   - **柱子 5**: 高度 `2`：
     - 栈顶高度 `6 > 2`，弹出 `(3, 6)`，计算面积：`maxArea = 6 * (4 - 3) = 6`
     - 栈顶高度 `5 > 2`，弹出 `(2, 5)`，计算面积：`maxArea = 5 * (4 - 2) = 10`
     - 更新起点索引：`start = 2`
     - 入栈：`stack = [(0, 1), (2, 2)]`
   - **柱子 6**: 高度 `3`：
     - 栈顶高度 `2 < 3`，直接入栈：`stack = [(0, 1), (2, 2), (5, 3)]`

3. 遍历栈中剩余柱子：
   - **柱子 `(0, 1)`**：计算面积：`maxArea = max(10, 1 * (6 - 0)) = 10`
   - **柱子 `(2, 2)`**：计算面积：`maxArea = max(10, 2 * (6 - 2)) = 10`
   - **柱子 `(5, 3)`**：计算面积：`maxArea = max(10, 3 * (6 - 5)) = 10`

4. 返回结果：
   ```python
   maxArea = 10
   ```

---

### **输出**：
```python
输入: [2, 1, 5, 6, 2, 3]
输出: 10
```

---

### **总结**：

- **关键点**：
  - 使用单调递增栈维护柱子的索引和高度。
  - 遇到高度降低时，计算以弹出柱子为高的矩形面积。

- **优点**：
  - 通过栈的方式高效计算面积，无需遍历多次。
  - 时间复杂度 \(O(n)\) 在大规模数据上表现良好。

---

### **柱状图中最大的矩形面积问题解析（中文详细讲解）**

---

#### **题目描述**
给定一个柱状图，每个柱子的高度由数组 `heights` 表示，求可以围成的最大的矩形面积。

---

### **代码实现**

```python
from typing import List

class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        maxArea = 0
        stack = []  # 用来存储柱子的起始索引和高度的栈
        
        for i, h in enumerate(heights):
            start = i
            while stack and stack[-1][1] > h:  # 当前柱子高度小于栈顶柱子
                index, height = stack.pop()  # 弹出栈顶柱子
                maxArea = max(maxArea, height * (i - index))  # 计算面积
                start = index  # 更新起点
            stack.append((start, h))  # 把当前柱子的起点和高度入栈

        for i, h in stack:  # 遍历栈中剩余柱子
            maxArea = max(maxArea, h * (len(heights) - i))  # 计算栈中剩余柱子的最大面积
        
        return maxArea
```

---

### **分步解析（中文详细版）**

#### **代码核心思路**
使用 **单调递增栈** 来实现高效计算：
1. **栈的内容**：栈中存储柱子的起始索引和高度 `(index, height)`。
2. **遇到更矮的柱子时**：
   - 弹出栈顶柱子，计算以弹出柱子为高度的矩形面积。
   - 继续弹出直到栈为空或栈顶柱子的高度不大于当前柱子的高度。
3. **遍历结束后**：
   - 栈中剩余的柱子，其右边界是数组末尾，逐一计算最大面积。

---

### **举例说明**

#### 输入：
```python
heights = [2, 1, 5, 6, 2, 3]
```

#### 运行过程：

1. 初始化：
   - `maxArea = 0`
   - `stack = []`

2. 遍历 `heights`：

| 当前柱子 | 栈内容（索引, 高度） | 处理步骤 | 当前最大面积 |
|:-------:|:-------------------:|:-------:|:-----------:|
| **2**   | `[]`                | 入栈 `(0, 2)` | `0`         |
| **1**   | `[(0, 2)]`          | 弹出 `(0, 2)`，计算面积：`2 * (1 - 0) = 2`<br>入栈 `(0, 1)` | `2` |
| **5**   | `[(0, 1)]`          | 入栈 `(1, 5)` | `2`         |
| **6**   | `[(0, 1), (1, 5)]`  | 入栈 `(2, 6)` | `2`         |
| **2**   | `[(0, 1), (1, 5), (2, 6)]` | 弹出 `(2, 6)`，计算面积：`6 * (4 - 2) = 6`<br>弹出 `(1, 5)`，计算面积：`5 * (4 - 1) = 15`<br>入栈 `(1, 2)` | `15` |
| **3**   | `[(0, 1), (1, 2)]`  | 入栈 `(4, 3)` | `15`        |

3. 遍历结束，处理栈中剩余柱子：
   - 弹出 `(4, 3)`，计算面积：`3 * (6 - 4) = 6`
   - 弹出 `(1, 2)`，计算面积：`2 * (6 - 1) = 10`
   - 弹出 `(0, 1)`，计算面积：`1 * (6 - 0) = 6`

#### 最终最大面积：
```python
maxArea = 15
```

---

### **时间复杂度和空间复杂度分析**

- **时间复杂度**：
  - 每个柱子最多入栈一次，出栈一次，因此时间复杂度为 **O(n)**。
- **空间复杂度**：
  - 使用了栈来存储柱子信息，最坏情况下栈的大小为柱子的数量，因此空间复杂度为 **O(n)**。

---

### **总结**

#### **核心思路**：
1. **单调递增栈**：栈中存储的柱子高度是递增的。
2. **弹出计算面积**：遇到更矮的柱子时，计算以栈顶柱子为高度的矩形面积。

#### **优点**：
- 相比暴力解法（两层嵌套循环），单调栈的时间复杂度更低，为 **O(n)**。
- 空间消耗小，适合大规模数据。

---

### **中文直观理解**

这段代码通过 **“维护一个递增的柱子高度栈”**，实现了计算最大矩形面积的目标。

- **直观图示**：
  假设柱子高度为 `[2, 1, 5, 6, 2, 3]`：
  ```
  初始：
  栈：[ ]
  maxArea：0
  ```
  每遍历到一个柱子：
  - 如果柱子高度比栈顶低，就意味着以栈顶柱子为高的矩形结束，开始计算面积。
  - 如果柱子高度比栈顶高，直接将柱子入栈。

通过这种方式，**每个柱子进栈一次、出栈一次**，高效计算了所有可能矩形的最大面积。
