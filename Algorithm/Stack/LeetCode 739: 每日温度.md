### LeetCode 739: 每日温度 (Daily Temperatures)

**题目描述**：  
给定一个整数列表 `temperatures`，其中 `temperatures[i]` 表示第 `i` 天的温度。请计算每一天需要等待多少天，才能等到一个更暖和的温度。如果没有这样的天数，则用 `0` 代替。

[LeetCode 739: Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)

**代码实现**：
```python
# 导入 collections 模块
from collections import defaultdict

# 定义解决方案的类
class Solution:
    # 定义每日温度计算函数
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        # 初始化结果数组和栈
        res = [0] * len(temperatures)
        stk = []  # 栈存储 (温度, 索引)

        # 遍历温度列表
        for i, t in enumerate(temperatures):
            # 当栈不为空且当前温度大于栈顶温度时，计算等待天数
            while stk and t > stk[-1][0]:
                stk_t, stk_i = stk.pop()
                res[stk_i] = i - stk_i  # 计算天数差，更新结果数组

            # 将当前温度及其索引压入栈中
            stk.append((t, i))

        return res

# 时间复杂度：O(n) - 每个元素最多入栈和出栈一次，其中 n 是温度列表的长度。
# 空间复杂度：O(n) - 最坏情况下栈存储所有元素。
```

**题目分析**：
该问题要求我们计算每一天需要等待的天数，直到遇到一个更高的温度。使用 **单调栈** 来处理这类问题尤为高效，因为它可以在遍历的同时维护一个递减栈，从而快速找到更高的温度。

**解决方案详解**：

- **初始化**：
  - 创建一个结果数组 `res`，初始值为 0，因为如果没有找到更高的温度，默认值为 0。
  - 使用一个单调栈 `stk`，存储当前温度和索引。

- **遍历温度列表**：
  - 对于每个温度，检查当前温度是否大于栈顶的温度：
    - 如果大于栈顶温度，说明找到了更高的温度，计算等待天数并更新结果数组。
    - 如果小于或等于栈顶温度，则将当前温度和索引压入栈中。

- **返回结果**：
  - 返回结果数组 `res`，其中每个元素表示等待的天数。

**复杂度分析**：
- **时间复杂度**：O(n)，其中 n 是温度列表的长度。每个元素最多入栈和出栈一次。
- **空间复杂度**：O(n)，最坏情况下栈中可能存储所有温度。

**示例讲解**：

#### 示例 1:

```python
输入: temperatures = [73, 74, 75, 71, 69, 72, 76, 73]
输出: [1, 1, 4, 2, 1, 1, 0, 0]
```

- 初始状态：`res = [0, 0, 0, 0, 0, 0, 0, 0]`, `stk = []`
- 第 0 天：`73` 压入栈，`stk = [(73, 0)]`
- 第 1 天：`74` 大于栈顶温度 `73`，更新 `res[0] = 1`，`stk = []`，`74` 压入栈。
- 第 2 天：`75` 大于栈顶温度 `74`，更新 `res[1] = 1`，`stk = []`，`75` 压入栈。
- 第 3 天：`71` 小于栈顶温度 `75`，压入栈，`stk = [(75, 2), (71, 3)]`。
- 第 4 天：`69` 小于栈顶温度 `71`，压入栈，`stk = [(75, 2), (71, 3), (69, 4)]`。
- 第 5 天：`72` 大于栈顶温度 `69` 和 `71`，更新 `res[4] = 1`，`res[3] = 2`，压入栈。
- 第 6 天：`76` 大于所有栈内温度，更新 `res[5] = 1`，`res[2] = 4`，压入栈。
- 最终结果：`[1, 1, 4, 2, 1, 1, 0, 0]`

**总结**：
- 使用单调栈适合处理需要找下一个更大/小元素的问题。  
- **Tips**：保持栈单调性可以帮助快速找到更高或更低的元素，从而提高效率。
