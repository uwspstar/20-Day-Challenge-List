### **题目：子集 (Subsets)**

**题目描述**：
给定一个不包含重复元素的整数数组 `nums`，返回该数组所有可能的子集（幂集）。

- 子集不能包含重复的子集。
- 返回的结果可以按任意顺序。

---

### **代码实现**

```python
from typing import List

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []  # 存储所有子集
        subset = []  # 临时存储当前子集

        # 深度优先搜索 (DFS) 函数
        def dfs(i):
            # 如果索引超出数组长度，将当前子集加入结果
            if i >= len(nums):
                res.append(subset.copy())  # 使用 copy() 防止后续修改影响
                return
            
            # 包含当前数字的情况
            subset.append(nums[i])
            dfs(i + 1)

            # 不包含当前数字的情况
            subset.pop()
            dfs(i + 1)
        
        dfs(0)  # 从索引 0 开始递归
        return res
```

---

### **时间和空间复杂度分析**

#### **时间复杂度**：
1. 每个数字有两种选择：**包含或不包含**，总共 \( 2^n \) 个子集。
2. 每次递归操作的时间复杂度为 \( O(n) \)，因为需要构造子集。

- **总时间复杂度**：\( O(2^n \cdot n) \)，其中 \( n \) 是数组的长度。

#### **空间复杂度**：
1. 递归的最大深度为 \( n \)，因此递归栈占用空间 \( O(n) \)。
2. 额外存储子集的空间为 \( O(2^n \cdot n) \)。
   
- **总空间复杂度**：\( O(2^n \cdot n) \)。

---

### **运行示例**

#### **输入**：
```python
nums = [1, 2, 3]
```

#### **运行过程**：

1. **初始状态**：
   - `res = []`
   - `subset = []`

2. **递归调用顺序**：
   - **`dfs(0)`**：
     - **包含数字 `1`**：
       - `subset = [1]`
       - **递归调用 `dfs(1)`**：
         - **包含数字 `2`**：
           - `subset = [1, 2]`
           - **递归调用 `dfs(2)`**：
             - **包含数字 `3`**：
               - `subset = [1, 2, 3]`
               - **递归调用 `dfs(3)`**：
                 - 达到边界，将 `[1, 2, 3]` 加入结果。
               - 回溯：`subset = [1, 2]`
             - **不包含数字 `3`**：
               - `subset = [1, 2]`
               - **递归调用 `dfs(3)`**：
                 - 达到边界，将 `[1, 2]` 加入结果。
               - 回溯：`subset = [1]`
         - **不包含数字 `2`**：
           - `subset = [1]`
           - **递归调用 `dfs(2)`**：
             - **包含数字 `3`**：
               - `subset = [1, 3]`
               - **递归调用 `dfs(3)`**：
                 - 达到边界，将 `[1, 3]` 加入结果。
               - 回溯：`subset = [1]`
             - **不包含数字 `3`**：
               - `subset = [1]`
               - **递归调用 `dfs(3)`**：
                 - 达到边界，将 `[1]` 加入结果。
               - 回溯：`subset = []`
     - **不包含数字 `1`**：
       - `subset = []`
       - **递归调用 `dfs(1)`**：
         - **包含数字 `2`**：
           - `subset = [2]`
           - **递归调用 `dfs(2)`**：
             - **包含数字 `3`**：
               - `subset = [2, 3]`
               - **递归调用 `dfs(3)`**：
                 - 达到边界，将 `[2, 3]` 加入结果。
               - 回溯：`subset = [2]`
             - **不包含数字 `3`**：
               - `subset = [2]`
               - **递归调用 `dfs(3)`**：
                 - 达到边界，将 `[2]` 加入结果。
               - 回溯：`subset = []`
         - **不包含数字 `2`**：
           - `subset = []`
           - **递归调用 `dfs(2)`**：
             - **包含数字 `3`**：
               - `subset = [3]`
               - **递归调用 `dfs(3)`**：
                 - 达到边界，将 `[3]` 加入结果。
               - 回溯：`subset = []`
             - **不包含数字 `3`**：
               - `subset = []`
               - **递归调用 `dfs(3)`**：
                 - 达到边界，将 `[]` 加入结果。

3. **结果**：
   - 最终结果：`res = [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]`

---

### **示例输出**
```python
输入: nums = [1, 2, 3]
输出: [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]
```

---

### **核心逻辑总结**
1. **递归与回溯**：
   - 使用 `dfs` 递归构造子集，遍历每个元素的包含与不包含情况。
   - 通过回溯撤销选择，恢复状态。

2. **深拷贝子集**：
   - 使用 `subset.copy()` 将当前子集加入结果，避免后续修改影响。

3. **时间复杂度**：
   - 每个元素有两种选择，共 \( 2^n \) 个子集。

---

如果还有疑问，欢迎继续提问！ 😊
