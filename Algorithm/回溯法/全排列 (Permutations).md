### **题目：全排列 (Permutations)**

给定一个不含重复数字的数组 `nums`，返回其所有可能的排列。

---

### **代码实现**

```python
from typing import List

class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        self.res = []  # 用于存储最终的结果
        self.backtrack([], nums, 0)  # 调用回溯函数
        return self.res

    def backtrack(self, perm: List[int], nums: List[int], mask: int):
        # 当排列长度等于数组长度时，将当前排列加入结果
        if len(perm) == len(nums):
            self.res.append(perm[:])  # 深拷贝当前排列
            return

        # 遍历每个数字
        for i in range(len(nums)):
            # 如果当前数字未被选中
            if not (mask & (1 << i)):
                # 选择当前数字
                perm.append(nums[i])
                # 递归选择剩余的数字
                self.backtrack(perm, nums, mask | (1 << i))
                # 回溯，撤销选择
                perm.pop()
```

---

### **代码解析**

#### **变量解释**：
1. `self.res`：
   - 存储所有排列结果。
2. `perm`：
   - 当前的排列状态。
3. `mask`：
   - 使用位掩码（bitmask）表示哪些数字已经被选中。
   - 每一位表示 `nums` 中对应索引是否已经被选中。例如：
     - `mask = 0b001` 表示第 0 个数字被选中，其他未选中。

#### **递归与回溯过程**：
1. **递归终止条件**：
   - 当 `perm` 的长度等于 `nums` 的长度时，表示当前排列已完成，将其加入结果。

2. **递归选择逻辑**：
   - 遍历 `nums` 的每个数字：
     - 如果数字未被选中（通过位运算检查），则将其加入 `perm` 并更新 `mask`，递归调用下一层。

3. **回溯撤销逻辑**：
   - 每次递归返回后，需要撤销上一步选择，即将当前数字从 `perm` 中移除，以便尝试其他选项。

---

### **时间和空间复杂度分析**

#### **时间复杂度**：
1. 每个数字有两种选择：**选中或不选中**，总共 \( n! \) 种排列。
2. 每次递归操作耗时 \( O(n) \)（用于构造排列）。
3. **总时间复杂度：\( O(n \times n!) \)**。

#### **空间复杂度**：
1. 递归栈的最大深度为 \( O(n) \)。
2. `perm` 和 `res` 占用的空间分别为 \( O(n) \) 和 \( O(n \times n!) \)。
3. **总空间复杂度：\( O(n \times n!) \)**。

---

### **运行示例**

#### **输入**：
```python
nums = [1, 2, 3]
```

#### **输出**：
```python
[
 [1, 2, 3],
 [1, 3, 2],
 [2, 1, 3],
 [2, 3, 1],
 [3, 1, 2],
 [3, 2, 1]
]
```

---

### **运行过程解析**

#### 初始状态：
- `self.res = []`
- `perm = []`
- `mask = 0`

#### 回溯过程：
1. **第一层递归**：
   - 遍历 `nums`，选择数字 `1`：
     - `perm = [1]`
     - `mask = 0b001`
     - 进入下一层递归。

2. **第二层递归**：
   - 遍历 `nums`，选择数字 `2`：
     - `perm = [1, 2]`
     - `mask = 0b011`
     - 进入下一层递归。

3. **第三层递归**：
   - 遍历 `nums`，选择数字 `3`：
     - `perm = [1, 2, 3]`
     - `mask = 0b111`
     - 长度满足条件，将 `[1, 2, 3]` 加入结果。
   - 回溯：撤销选择，`perm = [1, 2]`，`mask = 0b011`。

4. **继续回溯**：
   - 撤销选择 `2`，选择 `3`，重复上述逻辑，生成所有排列。

---

### **总结**

#### **核心逻辑**：
- 利用回溯法，通过递归构造排列。
- 使用位掩码优化选中状态的管理，减少额外空间开销。

#### **优点**：
- 高效管理已选状态，代码简洁清晰。
- 使用回溯方法避免重复计算。

---

如果有更多问题或需要进一步解释，欢迎随时提问！ 😊
