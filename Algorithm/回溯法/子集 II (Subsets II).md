### **题目：子集 II (Subsets II)**

**题目描述**：  
给定一个可能包含重复数字的整数数组 `nums`，返回该数组所有可能的子集（幂集）。  
**注意**：解集中不能包含重复的子集。

---

### **代码实现**

```python
from typing import List

class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = []  # 存储结果
        nums.sort()  # 先排序以便于处理重复元素

        def backtrack(i, subset):
            res.append(subset[::])  # 记录当前子集
            
            for j in range(i, len(nums)):
                # 如果当前数字与前一个数字相同且前一个数字未被使用，跳过以避免重复子集
                if j > i and nums[j] == nums[j - 1]:
                    continue
                subset.append(nums[j])  # 选择当前数字
                backtrack(j + 1, subset)  # 递归进入下一层
                subset.pop()  # 回溯，撤销选择
        
        backtrack(0, [])  # 从索引 0 开始回溯
        return res
```

---

### **代码解析**

#### **步骤解析**：
1. **排序**：  
   先对数组 `nums` 进行排序。排序的目的是为了让重复的数字相邻，方便跳过重复子集。

2. **回溯函数 `backtrack(i, subset)`**：  
   - **参数说明**：
     - `i`：当前的起始索引。
     - `subset`：当前子集。
   - **递归逻辑**：
     - 将当前子集加入结果集。
     - 遍历从索引 `i` 开始的每个数字：
       - 如果当前数字与前一个数字相同，且前一个数字未被使用，则跳过该数字。
       - 选择当前数字，递归进入下一层。
       - 回溯，撤销当前选择。

3. **跳过重复的逻辑**：
   - 条件 `if j > i and nums[j] == nums[j - 1]:` 检查当前数字是否与前一个数字相同。如果相同且在当前递归层中已经被跳过，则直接跳过当前数字。

---

### **时间和空间复杂度分析**

#### **时间复杂度**：
1. 生成所有子集：最多有 \( 2^n \) 个子集。
2. 对于每个子集，加入到结果集的操作耗时 \( O(n) \)。
3. 总时间复杂度为 **\( O(2^n \cdot n) \)**。

#### **空间复杂度**：
1. 递归的最大深度为 \( O(n) \)。
2. 子集列表的存储空间为 \( O(2^n \cdot n) \)。
3. 总空间复杂度为 **\( O(2^n \cdot n) \)**。

---

### **运行示例**

#### **输入**：
```python
nums = [1, 2, 2]
```

#### **运行过程**：
1. **排序后的数组**：
   ```python
   nums = [1, 2, 2]
   ```

2. **回溯过程**：
   - 初始状态：
     ```python
     subset = []
     res = [[]]  # 空子集
     ```

   - **第一层递归**：
     - 选择 `1`：
       ```python
       subset = [1]
       res = [[], [1]]
       ```
       进入下一层递归。

   - **第二层递归**：
     - 选择 `2`：
       ```python
       subset = [1, 2]
       res = [[], [1], [1, 2]]
       ```
       进入下一层递归。
     - 再选择 `2`：
       ```python
       subset = [1, 2, 2]
       res = [[], [1], [1, 2], [1, 2, 2]]
       ```
       回溯：
       ```python
       subset = [1, 2]
       ```

   - **回溯**：
     - 撤销选择 `2`，返回到上一层：
       ```python
       subset = [1]
       ```

   - 不选择 `2`：
     ```python
     subset = []
     ```

3. **最终结果**：
   ```python
   res = [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]
   ```

---

### **输出**

#### 示例 1：
```python
nums = [1, 2, 2]
输出: [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]
```

#### 示例 2：
```python
nums = [4, 4, 4, 1, 4]
输出: [[], [1], [1, 4], [1, 4, 4], [1, 4, 4, 4], [1, 4, 4, 4, 4], [4], [4, 4], [4, 4, 4], [4, 4, 4, 4]]
```

---

### **总结**

#### **核心逻辑**：
- 使用排序和跳过重复逻辑避免重复子集。
- 通过回溯递归生成所有可能的子集。

#### **优点**：
- 灵活处理重复数字。
- 易于理解的递归结构。
