# 位运算
### 位运算 (Bit Manipulation)

#### Definition  
位运算是对二进制数进行操作的一种技巧。位运算可以高效地进行一些数学运算、状态处理等操作，尤其在优化算法中表现优异。位运算常用于在操作系统、图像处理、压缩算法等领域。

#### Key Concepts  
1. **按位与 (AND) - `&`**: 两个位都为 1 时结果才为 1，否则为 0。
2. **按位或 (OR) - `|`**: 只要有一个位为 1，结果就为 1。
3. **按位异或 (XOR) - `^`**: 当两个位不同时，结果为 1，否则为 0。
4. **按位取反 (NOT) - `~`**: 将所有的位取反，0 变为 1，1 变为 0。
5. **左移 (Left Shift) - `<<`**: 将位左移 n 位，相当于乘以 2 的 n 次方。
6. **右移 (Right Shift) - `>>`**: 将位右移 n 位，相当于除以 2 的 n 次方。

#### 位运算的步骤  
1. **选择合适的位运算符**：根据需求选择 `&`、`|`、`^`、`~`、`<<` 或 `>>`。
2. **操作特定的位**：在操作特定位置的位时，通常会使用掩码 (mask) 来只影响特定的位。
3. **结合常见技巧**：位运算常与其他操作结合使用，例如通过异或来找出唯一数、左移右移来快速乘除。

#### 位运算的适用场景  
- 判断奇偶性：通过 `n & 1` 判断一个数是奇数还是偶数。
- 交换两数：通过 `a = a ^ b; b = a ^ b; a = a ^ b;` 交换两个数。
- 位计数：使用位运算来统计一个数的二进制中 1 的数量。

#### Python 位运算模板

```python
def bitwise_operation(a, b):
    # 按位与
    and_result = a & b
    # 按位或
    or_result = a | b
    # 按位异或
    xor_result = a ^ b
    # 按位取反
    not_result = ~a
    # 左移
    left_shift_result = a << 2
    # 右移
    right_shift_result = b >> 2
    return and_result, or_result, xor_result, not_result, left_shift_result, right_shift_result
```

### 5 道 LeetCode 位运算题目及详细解释

---

#### 1. LeetCode 136: 只出现一次的数字 (Single Number)

##### Problem Description  
给定一个非空整数数组，其中有一个数字只出现了一次，其余每个数字都出现两次。找出那个只出现一次的数字。

##### 解法：位运算 - 异或  
利用异或的性质：相同的数异或结果为 0，不同的数异或结果为 1。将数组中所有数字异或起来，出现两次的数字会互相抵消，最终剩下的就是只出现一次的数字。

##### Python 代码：

```python
def singleNumber(nums):
    result = 0
    # 遍历数组，逐个异或
    for num in nums:
        result ^= num
    return result
```

##### 解释：
- 使用异或操作逐个处理数组中的数字，最终的结果就是那个只出现一次的数字。

##### 时间复杂度：O(n)  
##### 空间复杂度：O(1)

---

#### 2. LeetCode 191: 位 1 的个数 (Number of 1 Bits)

##### Problem Description  
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 '1' 的个数（又称汉明重量）。

##### 解法：位运算 - 位与  
使用 `n & (n - 1)` 可以消除最低位的 1，直到 n 变为 0。

##### Python 代码：

```python
def hammingWeight(n):
    count = 0
    while n:
        # 消除最低位的 1
        n &= (n - 1)
        count += 1
    return count
```

##### 解释：
- 每次 `n & (n - 1)` 操作都会将 n 的最低位 1 变为 0，循环直到 n 变为 0。

##### 时间复杂度：O(1)  
##### 空间复杂度：O(1)

---

#### 3. LeetCode 231: 2 的幂 (Power of Two)

##### Problem Description  
给定一个整数，编写一个函数来判断它是否是 2 的幂。

##### 解法：位运算 - 位与  
2 的幂次方在二进制中只有一位是 1。使用 `n & (n - 1)` 判断 n 是否是 2 的幂次方。

##### Python 代码：

```python
def isPowerOfTwo(n):
    # 判断是否为正数，并且只有一位是 1
    return n > 0 and (n & (n - 1)) == 0
```

##### 解释：
- 使用 `n & (n - 1)` 消除最低位的 1，如果结果为 0，说明 n 是 2 的幂次方。

##### 时间复杂度：O(1)  
##### 空间复杂度：O(1)

---

#### 4. LeetCode 461: 汉明距离 (Hamming Distance)

##### Problem Description  
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给定两个整数，计算它们之间的汉明距离。

##### 解法：位运算 - 异或  
异或运算可以找出两个数字在二进制表示中不同的位。然后数一数异或结果中 1 的个数就是汉明距离。

##### Python 代码：

```python
def hammingDistance(x, y):
    # 计算 x 和 y 的异或
    xor = x ^ y
    # 计算异或结果中 1 的个数
    distance = 0
    while xor:
        xor &= xor - 1
        distance += 1
    return distance
```

##### 解释：
- 通过异或运算找到两个数字的不同位数，然后使用 `n & (n - 1)` 来计算 1 的数量。

##### 时间复杂度：O(1)  
##### 空间复杂度：O(1)

---

#### 5. LeetCode 338: 比特位计数 (Counting Bits)

##### Problem Description  
给定一个非负整数 `num`，对于 `0 ≤ i ≤ num` 范围中的每个数字 `i`，计算其二进制数中的 1 的个数，并将它们作为数组返回。

##### 解法：动态规划 + 位运算  
对于每个数字 `i`，其 1 的个数等于 `i >> 1` 的 1 的个数加上 `i` 的最低位是否为 1。

##### Python 代码：

```python
def countBits(num):
    dp = [0] * (num + 1)
    for i in range(1, num + 1):
        dp[i] = dp[i >> 1] + (i & 1)
    return dp
```

##### 解释：
- `i >> 1` 可以去掉 `i` 的最低位，其 1 的个数等于 `i // 2` 的 1 的个数加上最低位 `i & 1`。

##### 时间复杂度：O(n)  
##### 空间复杂度：O(n)

---

### Conclusion  
位运算是一种非常强大的技巧，可以高效处理二进制数据。在算法中，位运算可以用来快速计算、优化算法，适用于统计、交换、比较等场景。掌握位运算可以帮助更好地理解底层计算机运算的原理，并应用于实际开发中。
