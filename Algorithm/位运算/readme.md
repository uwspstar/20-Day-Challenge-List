# 位运算
### 位运算 (Bit Manipulation)

#### Definition  
位运算是对二进制数进行操作的一种技巧。位运算可以高效地进行一些数学运算、状态处理等操作，尤其在优化算法中表现优异。位运算常用于在操作系统、图像处理、压缩算法等领域。

#### Key Concepts  
1. **按位与 (AND) - `&`**: 两个位都为 1 时结果才为 1，否则为 0。
2. **按位或 (OR) - `|`**: 只要有一个位为 1，结果就为 1。
3. **按位异或 (XOR) - `^`**: 当两个位不同时，结果为 1，否则为 0。
4. **按位取反 (NOT) - `~`**: 将所有的位取反，0 变为 1，1 变为 0。
5. **左移 (Left Shift) - `<<`**: 将位左移 n 位，相当于乘以 2 的 n 次方。
6. **右移 (Right Shift) - `>>`**: 将位右移 n 位，相当于除以 2 的 n 次方。

#### 位运算的步骤  
1. **选择合适的位运算符**：根据需求选择 `&`、`|`、`^`、`~`、`<<` 或 `>>`。
2. **操作特定的位**：在操作特定位置的位时，通常会使用掩码 (mask) 来只影响特定的位。
3. **结合常见技巧**：位运算常与其他操作结合使用，例如通过异或来找出唯一数、左移右移来快速乘除。

#### 位运算的适用场景  
- 判断奇偶性：通过 `n & 1` 判断一个数是奇数还是偶数。
- 交换两数：通过 `a = a ^ b; b = a ^ b; a = a ^ b;` 交换两个数。
- 位计数：使用位运算来统计一个数的二进制中 1 的数量。

#### Python 位运算模板

```python
def bitwise_operation(a, b):
    # 按位与
    and_result = a & b
    # 按位或
    or_result = a | b
    # 按位异或
    xor_result = a ^ b
    # 按位取反
    not_result = ~a
    # 左移
    left_shift_result = a << 2
    # 右移
    right_shift_result = b >> 2
    return and_result, or_result, xor_result, not_result, left_shift_result, right_shift_result
```

好的，我们从 LeetCode 位运算题目开始详细讲解，包括逐行中文注释代码及时间和空间复杂度分析。以下是前五道题目的详细解释。

---

### 1. LeetCode 136: Single Number（只出现一次的数字）

**题目描述**：
给定一个非空整数数组 `nums`，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**题目分析**：
可以利用位运算中的异或（XOR）操作来解决该问题。异或的性质是：`a ^ a = 0`，`a ^ 0 = a`，即相同的数异或结果为 0，不同的数异或结果为该数本身。因此，数组中所有数异或的结果就是那个只出现一次的数。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义查找只出现一次数字的函数
    def singleNumber(self, nums: List[int]) -> int:
        # 初始化异或结果为 0
        result = 0
        # 遍历数组中的每个元素并异或
        for num in nums:
            result ^= num  # 将当前元素与结果异或
        return result  # 返回异或后的结果

# 时间复杂度：O(n) - 遍历数组一次
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(n)，其中 n 是数组的长度，因为每个元素只会被访问一次。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间（异或结果变量）。

---

### 2. LeetCode 137: Single Number II（只出现一次的数字 II）

**题目描述**：
给定一个整数数组 `nums`，其中恰好有一个元素只出现一次，其余每个元素都出现三次。找出那个只出现了一次的元素。

**题目分析**：
可以使用位运算来解决该问题。对于每一个二进制位，统计所有数字中该位上 1 的个数，如果该位上 1 的个数不是 3 的倍数，则说明只出现一次的数字在该位上有 1。最后将这些位拼接起来即为目标数字。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义查找只出现一次数字的函数
    def singleNumber(self, nums: List[int]) -> int:
        # 初始化一个包含 32 位的数组来统计每个位上 1 的个数
        bit_count = [0] * 32

        # 统计每个数字的每个位上的 1 的个数
        for num in nums:
            for i in range(32):
                # 检查当前位是否为 1，并更新计数
                bit_count[i] += (num >> i) & 1

        # 根据每个位上 1 的个数恢复只出现一次的数字
        result = 0
        for i in range(32):
            # 如果当前位上 1 的个数不是 3 的倍数，则说明只出现一次的数字在该位上有 1
            if bit_count[i] % 3:
                # 如果 i 位为符号位（最高位），则需进行负数处理
                if i == 31:
                    result -= (1 << i)
                else:
                    result |= (1 << i)

        return result

# 时间复杂度：O(n) - 遍历数组一次，并对每个数的 32 位进行操作
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(n)，其中 n 是数组的长度，每个数字的 32 位都需要被检查。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间（32 位的计数数组）。

---

### 3. LeetCode 190: Reverse Bits（颠倒二进制位）

**题目描述**：
颠倒给定的 32 位无符号整数的二进制位。

**题目分析**：
可以使用位运算和循环来逐位交换整数的二进制表示。每次将当前整数的最低位与目标整数的最高位交换，直到所有 32 位被处理完。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义颠倒二进制位的函数
    def reverseBits(self, n: int) -> int:
        # 初始化结果为 0
        result = 0
        for i in range(32):
            # 获取当前整数的最低位
            bit = (n >> i) & 1
            # 将最低位移动到结果中的最高位
            result |= (bit << (31 - i))
        return result

# 时间复杂度：O(1) - 固定的 32 位操作
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为只需处理 32 位的固定长度。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 4. LeetCode 191: Number of 1 Bits（位1的个数）

**题目描述**：
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 `1` 的个数（也被称为汉明重量）。

**题目分析**：
可以通过逐位检查每个二进制位是否为 `1` 来解决该问题。每次将整数右移一位，并检查最低位是否为 `1`，直到所有位都被处理完。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义统计二进制位中1的个数的函数
    def hammingWeight(self, n: int) -> int:
        # 初始化计数器为 0
        count = 0
        # 遍历每一位
        while n:
            # 检查当前位是否为 1，并更新计数
            count += n & 1
            # 右移一位
            n >>= 1
        return count

# 时间复杂度：O(1) - 固定的 32 位操作
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为无论输入的值是多少，总共有 32 位需要被处理。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 5. LeetCode 231: Power of Two（2 的幂）

**题目描述**：
给定一个整数，编写一个函数来判断它是否是 `2` 的幂次方。

**题目分析**：
一个数如果是 `2` 的幂次方，则它的二进制表示中只有一个 `1`，其余全为 `0`。因此，可以利用 `n & (n - 1)` 来判断 `n` 是否是 `2` 的幂次方。如果 `n` 是 `2` 的幂次方，则 `n & (n - 1) == 0`。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义判断是否为2的幂的函数
    def isPowerOfTwo(self, n: int) -> bool:
        # 负数和 0 不能是 2 的幂
        if n <= 0:
            return False
        # 使用 n & (n - 1) 判断是否为 2 的幂
        return (n & (n - 1)) == 0

# 时间复杂度：O(1) - 只需进行一次位运算
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为只需进行一次位运算。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

好的，我们继续讲解接下来的五道 LeetCode 位运算题目，包括题目描述、逐行中文注释代码及复杂度分析。

---

### 6. LeetCode 268: Missing Number（缺失数字）

**题目描述**：
给定一个包含 `0` 到 `n` 中 `n` 个不同数字的数组 `nums`，找出其中缺失的那个数字。

**题目分析**：
可以使用异或运算来解决该问题。将所有数组元素与 `0` 到 `n` 的所有数字进行异或操作。因为异或具有相同数字相消的特性，最终的结果就是缺失的数字。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义查找缺失数字的函数
    def missingNumber(self, nums: List[int]) -> int:
        # 初始化异或结果为 0
        xor_sum = 0
        # 将数组元素与 0 到 n 的数字进行异或
        for i in range(len(nums) + 1):
            xor_sum ^= i  # 与 0 到 n 的数字异或
        for num in nums:
            xor_sum ^= num  # 与数组元素异或
        return xor_sum  # 返回缺失的数字

# 时间复杂度：O(n) - 遍历数组和 0 到 n 的所有数字各一次
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(n)，因为需要遍历数组和所有 `0` 到 `n` 的数字各一次。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 7. LeetCode 389: Find the Difference（找不同）

**题目描述**：
给定两个字符串 `s` 和 `t`，其中 `t` 是 `s` 的一个随机排列并在随机位置添加了一个额外的字母。找出 `t` 中额外添加的那个字母。

**题目分析**：
可以使用异或运算来解决该问题。将两个字符串中所有字符进行异或操作，结果就是那个额外添加的字符。因为相同字符异或结果为 `0`，所以最终结果就是多余的字符。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义查找不同字符的函数
    def findTheDifference(self, s: str, t: str) -> str:
        # 初始化异或结果为 0
        result = 0
        # 将 s 和 t 中所有字符进行异或
        for char in s:
            result ^= ord(char)  # 将字符转换为 ASCII 值并异或
        for char in t:
            result ^= ord(char)
        # 将最终结果转换为字符返回
        return chr(result)

# 时间复杂度：O(n) - 遍历 s 和 t 的所有字符各一次
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(n)，其中 n 是字符串的长度，遍历 s 和 t 的所有字符各一次。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 8. LeetCode 371: Sum of Two Integers（两整数之和）

**题目描述**：
不使用运算符 `+` 和 `-`，计算两整数 `a` 和 `b` 之和。

**题目分析**：
可以使用位运算中的 **异或** 和 **与** 操作来实现两数相加。异或操作相当于不考虑进位的加法，而与操作可以用于计算进位。通过循环将异或结果和进位相加，直到进位为 `0`。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义计算两整数之和的函数
    def getSum(self, a: int, b: int) -> int:
        # 使用循环不断将异或结果和进位相加
        while b != 0:
            # 计算进位
            carry = (a & b) << 1
            # 计算不考虑进位的加法
            a = a ^ b
            # 将进位赋值给 b
            b = carry
        return a

# 时间复杂度：O(1) - 常数次循环，最多处理 32 位整数
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为整数的位数是固定的（32 位或 64 位），因此最多进行常数次操作。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 9. LeetCode 693: Binary Number with Alternating Bits（交替位二进制数）

**题目描述**：
给定一个正整数，检查它的二进制表示是否为交替位，即相邻的两个位数是否不同。

**题目分析**：
可以使用位运算来判断交替位。将整数右移一位，并与原整数异或，如果结果全为 `1`（即满足 `n ^ (n >> 1) == 2^k - 1`），则说明该整数是交替位二进制数。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义判断是否为交替位二进制数的函数
    def hasAlternatingBits(self, n: int) -> bool:
        # 计算 n 与右移 1 位后的 n 的异或结果
        xor_result = n ^ (n >> 1)
        # 检查异或结果是否全为 1（即与 2^k - 1 的值进行比较）
        return (xor_result & (xor_result + 1)) == 0

# 时间复杂度：O(1) - 只需进行常数次位运算
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为整数的位数是固定的（32 位或 64 位），因此最多进行常数次操作。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 10. LeetCode 461: Hamming Distance（汉明距离）

**题目描述**：
两个整数的汉明距离是对应位置不同的二进制位的数量。给定两个整数 `x` 和 `y`，计算它们之间的汉明距离。

**题目分析**：
可以通过异或运算来求解汉明距离。异或运算的结果中，每个 `1` 代表 `x` 和 `y` 在该位上的值不同。统计异或结果中 `1` 的个数即可得到汉明距离。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义计算汉明距离的函数
    def hammingDistance(self, x: int, y: int) -> int:
        # 计算 x 和 y 的异或结果
        xor_result = x ^ y
        # 统计异或结果中 1 的个数
        count = 0
        while xor_result:
            # 统计最低位是否为 1
            count += xor_result & 1
            # 右移一位
            xor_result >>= 1
        return count

# 时间复杂度：O(1) - 最多处理 32 位或 64 位整数
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为无论输入的值是多少，总共只有 32 位或 64 位需要被处理。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

好的，我们继续讲解接下来的五道 LeetCode 位运算题目，包括题目描述、逐行中文注释代码及复杂度分析。

---

### 11. LeetCode 201: Bitwise AND of Numbers Range（数字范围按位与）

**题目描述**：
给定两个整数 `m` 和 `n`，返回该区间内所有数字按位与的结果（包括 `m` 和 `n`）。

**题目分析**：
可以使用移位操作来解决该问题。由于在按位与操作时，只要区间内的数字在某一位上存在 `0`，该位最终结果就一定为 `0`。因此，可以通过不断右移 `m` 和 `n` 直到它们相等，再将它们左移回去，即得到了按位与的结果。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义计算数字范围按位与的函数
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        # 记录左移的位数
        shift = 0
        # 不断右移 m 和 n，直到它们相等
        while m < n:
            m >>= 1
            n >>= 1
            shift += 1
        # 将 m 左移回原来的位置
        return m << shift

# 时间复杂度：O(log n) - 每次右移操作将数字缩小一半
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(log n)，每次右移操作将数字缩小一半，最多进行 log n 次操作。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 12. LeetCode 260: Single Number III（只出现一次的数字 III）

**题目描述**：
给定一个整数数组 `nums`，其中正好有两个元素只出现一次，其余每个元素均出现两次。找出这两个只出现一次的元素。

**题目分析**：
可以使用异或运算来解决该问题。首先将所有数字进行异或，得到两个只出现一次的数字的异或结果。然后通过找到异或结果中第一个不为 `0` 的位（表示这两个数字在该位上不同），将数组分为两组，再分别对两组进行异或运算，即可得到两个只出现一次的数字。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义查找只出现一次的两个数字的函数
    def singleNumber(self, nums: List[int]) -> List[int]:
        # 计算所有数字的异或结果
        xor_sum = 0
        for num in nums:
            xor_sum ^= num

        # 找到异或结果中第一个不为 0 的位（表示这两个数字在该位上不同）
        diff = xor_sum & -xor_sum

        # 初始化两个只出现一次的数字
        x, y = 0, 0
        for num in nums:
            # 根据当前位是否为 0，将数字分为两组，并分别进行异或
            if num & diff:
                x ^= num
            else:
                y ^= num

        return [x, y]

# 时间复杂度：O(n) - 遍历数组两次
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(n)，因为需要遍历数组两次，一次用于计算异或结果，一次用于分组。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 13. LeetCode 342: Power of Four（4 的幂）

**题目描述**：
给定一个整数，编写一个函数来判断它是否是 `4` 的幂次方。

**题目分析**：
可以通过位运算来判断一个数是否是 `4` 的幂。`4` 的幂在二进制中表现为 `1` 后面跟着偶数个 `0`。因此，首先判断它是否是 `2` 的幂次方（即 `n & (n - 1) == 0`），然后再判断 `1` 的位置是否在偶数位上（即 `n & 0x55555555 != 0`）。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义判断是否为 4 的幂的函数
    def isPowerOfFour(self, n: int) -> bool:
        # 判断 n 是否是 2 的幂，并且 1 的位置在偶数位上
        return n > 0 and (n & (n - 1)) == 0 and (n & 0x55555555) != 0

# 时间复杂度：O(1) - 只需进行常数次位运算
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为只需进行常数次位运算。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 14. LeetCode 338: Counting Bits（比特位计数）

**题目描述**：
给定一个非负整数 `num`，对于 `0 ≤ i ≤ num` 范围中的每个数字 `i`，计算其二进制表示中 `1` 的个数，并将它们作为数组返回。

**题目分析**：
可以使用动态规划来解决该问题。对于每个数字 `i`，它的 `1` 的个数可以由以下关系得到：`bits[i] = bits[i >> 1] + (i & 1)`。即 `i` 的 `1` 的个数等于 `i` 右移一位的 `1` 的个数加上最低位是否为 `1`。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义计算比特位计数的函数
    def countBits(self, num: int) -> List[int]:
        # 初始化结果数组，大小为 num + 1
        bits = [0] * (num + 1)
        # 逐个计算 0 到 num 中每个数字的 1 的个数
        for i in range(1, num + 1):
            bits[i] = bits[i >> 1] + (i & 1)
        return bits

# 时间复杂度：O(n) - 逐个计算 0 到 num 中每个数字的 1 的个数
# 空间复杂度：O(n) - 存储比特位计数的结果数组
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(n)，因为需要逐个计算 0 到 `num` 中每个数字的 `1` 的个数。
- **空间复杂度**：O(n)，用于存储比特位计数结果的数组。

---

### 15. LeetCode 476: Number Complement（数字的补数）

**题目描述**：
给定一个正整数，返回它的补数。补数是该数字的二进制表示中每一位的反码（即 `0` 变 `1`，`1` 变 `0`）。

**题目分析**：
可以通过位运算来求解补数。首先构造一个掩码，该掩码是与给定整数位数相同的全 `1` 的二进制数，然后通过 `n ^ mask` 来反转所有位。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义计算数字补数的函数
    def findComplement(self, num: int) -> int:
        # 初始化掩码为全 1 的二进制数
        mask = 1
        # 将掩码扩展到与 num 相同的位数
        while mask < num:
            mask = (mask << 1) | 1
        # 计算补数
        return num ^ mask

# 时间复杂度：O(1) - 常数次位运算，最多处理 32 位整数
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为整数的位数是固定的（32 位或 64 位），因此最多进行常数次操作。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

好的，我们继续讲解接下来的五道 LeetCode 位运算题目，包括题目描述、逐行中文注释代码及复杂度分析。

---

### 16. LeetCode 190: Reverse Bits（颠倒二进制位）

**题目描述**：
颠倒给定的 32 位无符号整数的二进制位。

**题目分析**：
可以使用位运算和循环来逐位交换整数的二进制表示。每次将当前整数的最低位与目标整数的最高位交换，直到所有 32 位被处理完。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义颠倒二进制位的函数
    def reverseBits(self, n: int) -> int:
        # 初始化结果为 0
        result = 0
        # 遍历 32 位的每一位
        for i in range(32):
            # 获取 n 的最低位
            bit = (n >> i) & 1
            # 将该位移到结果中的最高位
            result |= (bit << (31 - i))
        return result  # 返回最终的结果

# 时间复杂度：O(1) - 固定 32 位操作
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为无论输入是多少，总共只有 32 位需要被处理。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 17. LeetCode 393: UTF-8 Validation（UTF-8 编码验证）

**题目描述**：
给定一个表示数据的整数数组，验证它是否为有效的 UTF-8 编码。有效的 UTF-8 编码规则如下：
1. 1 字节（ASCII）：`0xxxxxxx`。
2. 2 字节：`110xxxxx 10xxxxxx`。
3. 3 字节：`1110xxxx 10xxxxxx 10xxxxxx`。
4. 4 字节：`11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`。

**题目分析**：
可以通过位运算来解析和验证每个字节的编码格式。首先判断首字节的类型，然后检查后续字节是否符合 `10xxxxxx` 的格式。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义 UTF-8 编码验证的函数
    def validUtf8(self, data: List[int]) -> bool:
        # 定义所需验证的后续字节数
        count = 0

        # 检查每个字节
        for num in data:
            # 获取当前字节的后 8 位（只处理 1 字节部分）
            byte = num & 0xFF

            if count == 0:
                # 确定当前字节是几字节字符
                if (byte >> 5) == 0b110:  # 2 字节字符
                    count = 1
                elif (byte >> 4) == 0b1110:  # 3 字节字符
                    count = 2
                elif (byte >> 3) == 0b11110:  # 4 字节字符
                    count = 3
                elif (byte >> 7) != 0:  # 1 字节字符应以 0 开头
                    return False
            else:
                # 验证当前字节是否为 10xxxxxx 格式
                if (byte >> 6) != 0b10:
                    return False
                count -= 1

        # 如果所有字符验证完成后，count 仍不为 0，则说明格式错误
        return count == 0

# 时间复杂度：O(n) - 遍历所有字节
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(n)，因为需要遍历所有字节来进行验证。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 18. LeetCode 693: Binary Number with Alternating Bits（交替位二进制数）

**题目描述**：
给定一个正整数，检查它的二进制表示是否为交替位，即相邻的两个位数是否不同。

**题目分析**：
可以使用位运算来判断交替位。将整数右移一位，并与原整数异或，如果结果全为 `1`（即满足 `n ^ (n >> 1) == 2^k - 1`），则说明该整数是交替位二进制数。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义判断是否为交替位二进制数的函数
    def hasAlternatingBits(self, n: int) -> bool:
        # 计算 n 与右移 1 位后的 n 的异或结果
        xor_result = n ^ (n >> 1)
        # 检查异或结果是否全为 1（即与 2^k - 1 的值进行比较）
        return (xor_result & (xor_result + 1)) == 0

# 时间复杂度：O(1) - 只需进行常数次位运算
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为整数的位数是固定的（32 位或 64 位），因此最多进行常数次操作。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 19. LeetCode 201: Bitwise AND of Numbers Range（数字范围按位与）

**题目描述**：
给定两个整数 `m` 和 `n`，返回该区间内所有数字按位与的结果（包括 `m` 和 `n`）。

**题目分析**：
可以使用移位操作来解决该问题。由于在按位与操作时，只要区间内的数字在某一位上存在 `0`，该位最终结果就一定为 `0`。因此，可以通过不断右移 `m` 和 `n` 直到它们相等，再将它们左移回去，即得到了按位与的结果。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义计算数字范围按位与的函数
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        # 记录左移的位数
        shift = 0
        # 不断右移 m 和 n，直到它们相等
        while m < n:
            m >>= 1
            n >>= 1
            shift += 1
        # 将 m 左移回原来的位置
        return m << shift

# 时间复杂度：O(log n) - 每次右移操作将数字缩小一半
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(log n)，每次右移操作将数字缩小一半，最多进行 log n 次操作。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 20. LeetCode 477: Total Hamming Distance（汉明距离总和）

**题目描述**：
给定一个整数数组 `nums`，返回所有数对之间的汉明距离总和。

**题目分析**：
可以逐位统计所有数在每个二进制位上 `1` 和 `0` 的个数。对于每个二进制位，如果在该位上有 `c` 个数是 `1`，则有 `len(nums) - c` 个数是 `0`，则该位上的汉明距离总和为 `c * (len(nums) - c)`。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义计算汉明距离总和的函数
    def totalHammingDistance(self, nums: List[int]) -> int:
        # 初始化总和为 0
        total_distance = 0
        # 逐位统计所有数字在每个二进制位上的 1 和 0 的个数
        for i in range(32):  # 处理 32 位整数
            count_ones = sum((num >> i) & 1 for num in nums)
            # 计算当前位上的汉明距离
            total_distance += count_ones * (len(nums) - count_ones)
        return total_distance

# 时间复杂度：O(n) - 遍历每个数字的 32 位
# 空间复杂度：O

(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(n)，因为对于每个二进制位，遍历所有的数字进行统计。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

好的，我们继续讲解接下来的五道 LeetCode 位运算题目，包括题目描述、逐行中文注释代码及复杂度分析。

---

### 21. LeetCode 89: Gray Code（格雷编码）

**题目描述**：
给定一个非负整数 `n`，表示二进制的位数，返回其格雷编码序列。格雷编码序列是一种二进制编码形式，其中两个相邻数值的二进制数只有一位不同。

**题目分析**：
格雷编码可以通过公式 `G(i) = i ^ (i >> 1)` 生成，即格雷码的第 `i` 个数等于 `i` 与 `i` 右移一位后进行异或的结果。利用这个公式可以直接生成 `0` 到 `2^n - 1` 范围内的所有格雷编码。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义生成格雷编码的函数
    def grayCode(self, n: int) -> List[int]:
        # 生成 0 到 2^n - 1 的格雷编码序列
        return [i ^ (i >> 1) for i in range(1 << n)]

# 时间复杂度：O(2^n) - 生成 2^n 个格雷编码
# 空间复杂度：O(2^n) - 存储格雷编码序列
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(2^n)，生成 `2^n` 个格雷编码。
- **空间复杂度**：O(2^n)，用于存储格雷编码序列。

---

### 22. LeetCode 421: Maximum XOR of Two Numbers in an Array（数组中两个数的最大异或值）

**题目描述**：
给定一个整数数组 `nums`，返回该数组中任意两个不同元素 `nums[i]` 和 `nums[j]` 的最大异或值。

**题目分析**：
可以使用字典树（Trie）来求解该问题。首先将数组中所有数字的二进制形式插入到字典树中，然后遍历数组，找到与当前数字异或值最大的另一个数字。通过逐位检查，可以在字典树中找到最优的匹配路径，从而得到最大异或值。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义查找数组中两个数的最大异或值的函数
    def findMaximumXOR(self, nums: List[int]) -> int:
        # 定义字典树节点类
        class TrieNode:
            def __init__(self):
                self.children = {}

        # 插入数字到字典树中
        def insert(num):
            node = root
            for i in range(31, -1, -1):  # 从最高位到最低位插入
                bit = (num >> i) & 1  # 获取当前位的值
                if bit not in node.children:
                    node.children[bit] = TrieNode()
                node = node.children[bit]

        # 查找与当前数字异或值最大的数
        def find_max_xor(num):
            node = root
            max_xor = 0
            for i in range(31, -1, -1):  # 从最高位到最低位查找
                bit = (num >> i) & 1
                # 尝试选择相反的位以得到更大的异或值
                toggle_bit = 1 - bit
                if toggle_bit in node.children:
                    max_xor = (max_xor << 1) | 1  # 更新异或值
                    node = node.children[toggle_bit]
                else:
                    max_xor = max_xor << 1  # 无法选择相反的位
                    node = node.children[bit]
            return max_xor

        # 初始化字典树
        root = TrieNode()
        # 插入所有数字到字典树中
        for num in nums:
            insert(num)

        # 查找数组中两个数的最大异或值
        max_result = 0
        for num in nums:
            max_result = max(max_result, find_max_xor(num))

        return max_result

# 时间复杂度：O(n) - 插入和查找字典树的复杂度均为 O(n)
# 空间复杂度：O(n) - 字典树的空间复杂度为 O(n)
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(n)，因为插入和查找字典树的复杂度均为 O(n)。
- **空间复杂度**：O(n)，用于存储字典树的节点。

---

### 23. LeetCode 693: Binary Number with Alternating Bits（交替位二进制数）

**题目描述**：
给定一个正整数，检查它的二进制表示是否为交替位，即相邻的两个位数是否不同。

**题目分析**：
可以使用位运算来判断交替位。将整数右移一位，并与原整数异或，如果结果全为 `1`（即满足 `n ^ (n >> 1) == 2^k - 1`），则说明该整数是交替位二进制数。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义判断是否为交替位二进制数的函数
    def hasAlternatingBits(self, n: int) -> bool:
        # 计算 n 与右移 1 位后的 n 的异或结果
        xor_result = n ^ (n >> 1)
        # 检查异或结果是否全为 1（即与 2^k - 1 的值进行比较）
        return (xor_result & (xor_result + 1)) == 0

# 时间复杂度：O(1) - 只需进行常数次位运算
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为整数的位数是固定的（32 位或 64 位），因此最多进行常数次操作。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 24. LeetCode 191: Number of 1 Bits（位1的个数）

**题目描述**：
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 `1` 的个数（也被称为汉明重量）。

**题目分析**：
可以通过逐位检查每个二进制位是否为 `1` 来解决该问题。每次将整数右移一位，并检查最低位是否为 `1`，直到所有位都被处理完。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义统计二进制位中1的个数的函数
    def hammingWeight(self, n: int) -> int:
        # 初始化计数器为 0
        count = 0
        # 遍历每一位
        while n:
            # 检查当前位是否为 1，并更新计数
            count += n & 1
            # 右移一位
            n >>= 1
        return count

# 时间复杂度：O(1) - 固定的 32 位操作
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为无论输入的值是多少，总共只有 32 位或 64 位需要被处理。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 25. LeetCode 393: UTF-8 Validation（UTF-8 编码验证）

**题目描述**：
给定一个表示数据的整数数组，验证它是否为有效的 UTF-8 编码。有效的 UTF-8 编码规则如下：
1. 1 字节（ASCII）：`0xxxxxxx`。
2. 2 字节：`110xxxxx 10xxxxxx`。
3. 3 字节：`1110xxxx 10xxxxxx 10xxxxxx`。
4. 4 字节：`11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`。

**题目分析**：
可以通过位运算来解析和验证每个字节的编码格式。首先判断首字节的类型，然后检查后续字节是否符合 `10xxxxxx` 的格式。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义 UTF-8 编码验证的函数
    def validUtf8(self, data: List[int]) -> bool:
        # 定义所需验证的后续字节数
        count = 0

        # 检查每

个字节
        for num in data:
            # 获取当前字节的后 8 位（只处理 1 字节部分）
            byte = num & 0xFF

            if count == 0:
                # 确定当前字节是几字节字符
                if (byte >> 5) == 0b110:  # 2 字节字符
                    count = 1
                elif (byte >> 4) == 0b1110:  # 3 字节字符
                    count = 2
                elif (byte >> 3) == 0b11110:  # 4 字节字符
                    count = 3
                elif (byte >> 7) != 0:  # 1 字节字符应以 0 开头
                    return False
            else:
                # 验证当前字节是否为 10xxxxxx 格式
                if (byte >> 6) != 0b10:
                    return False
                count -= 1

        # 如果所有字符验证完成后，count 仍不为 0，则说明格式错误
        return count == 0

# 时间复杂度：O(n) - 遍历所有字节
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(n)，因为需要遍历所有字节来进行验证。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

好的，我们继续讲解接下来的五道 LeetCode 位运算题目，包括题目描述、逐行中文注释代码及复杂度分析。

---

### 26. LeetCode 393: UTF-8 Validation（UTF-8 编码验证）

**题目描述**：
给定一个表示数据的整数数组，验证它是否为有效的 UTF-8 编码。有效的 UTF-8 编码规则如下：
1. 1 字节（ASCII）：`0xxxxxxx`。
2. 2 字节：`110xxxxx 10xxxxxx`。
3. 3 字节：`1110xxxx 10xxxxxx 10xxxxxx`。
4. 4 字节：`11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`。

**题目分析**：
可以通过位运算来解析和验证每个字节的编码格式。首先判断首字节的类型，然后检查后续字节是否符合 `10xxxxxx` 的格式。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义 UTF-8 编码验证的函数
    def validUtf8(self, data: List[int]) -> bool:
        # 定义所需验证的后续字节数
        count = 0

        # 检查每个字节
        for num in data:
            # 获取当前字节的后 8 位（只处理 1 字节部分）
            byte = num & 0xFF

            if count == 0:
                # 确定当前字节是几字节字符
                if (byte >> 5) == 0b110:  # 2 字节字符
                    count = 1
                elif (byte >> 4) == 0b1110:  # 3 字节字符
                    count = 2
                elif (byte >> 3) == 0b11110:  # 4 字节字符
                    count = 3
                elif (byte >> 7) != 0:  # 1 字节字符应以 0 开头
                    return False
            else:
                # 验证当前字节是否为 10xxxxxx 格式
                if (byte >> 6) != 0b10:
                    return False
                count -= 1

        # 如果所有字符验证完成后，count 仍不为 0，则说明格式错误
        return count == 0

# 时间复杂度：O(n) - 遍历所有字节
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(n)，因为需要遍历所有字节来进行验证。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 27. LeetCode 461: Hamming Distance（汉明距离）

**题目描述**：
两个整数的汉明距离是对应位置不同的二进制位的数量。给定两个整数 `x` 和 `y`，计算它们之间的汉明距离。

**题目分析**：
可以通过异或运算来求解汉明距离。异或运算的结果中，每个 `1` 代表 `x` 和 `y` 在该位上的值不同。统计异或结果中 `1` 的个数即可得到汉明距离。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义计算汉明距离的函数
    def hammingDistance(self, x: int, y: int) -> int:
        # 计算 x 和 y 的异或结果
        xor_result = x ^ y
        # 统计异或结果中 1 的个数
        count = 0
        while xor_result:
            # 统计最低位是否为 1
            count += xor_result & 1
            # 右移一位
            xor_result >>= 1
        return count

# 时间复杂度：O(1) - 最多处理 32 位或 64 位整数
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为无论输入的值是多少，总共只有 32 位或 64 位需要被处理。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 28. LeetCode 318: Maximum Product of Word Lengths（最大单词长度乘积）

**题目描述**：
给定一个字符串数组 `words`，找出两个不包含相同字符的单词 `words[i]` 和 `words[j]` 的长度乘积的最大值。假设每个单词只包含小写字母。如果不存在这样的两个单词，返回 `0`。

**题目分析**：
可以使用位运算来加速判断两个单词是否有相同的字符。通过将每个单词映射为一个 26 位的二进制数，其中每一位代表该单词中是否包含对应字母，然后只需通过按位与操作判断两个单词是否有相同字符。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义查找最大单词长度乘积的函数
    def maxProduct(self, words: List[str]) -> int:
        # 初始化字典保存每个单词对应的二进制表示及其长度
        bit_masks = {}
        for word in words:
            # 计算每个单词的二进制表示
            mask = 0
            for char in word:
                mask |= 1 << (ord(char) - ord('a'))  # 将字母映射为二进制位
            # 只保存每个二进制表示下的最大单词长度
            bit_masks[mask] = max(bit_masks.get(mask, 0), len(word))

        # 初始化最大乘积
        max_product = 0
        # 遍历所有二进制表示组合，查找不相交的单词组合
        for x in bit_masks:
            for y in bit_masks:
                if x & y == 0:  # 如果 x 和 y 按位与为 0，则说明两个单词没有相同字符
                    max_product = max(max_product, bit_masks[x] * bit_masks[y])

        return max_product

# 时间复杂度：O(n^2) - 遍历所有二进制表示组合
# 空间复杂度：O(n) - 存储二进制表示及单词长度的字典
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(n^2)，需要遍历所有二进制表示组合，进行按位与判断。
- **空间复杂度**：O(n)，用于存储每个单词的二进制表示及其长度。

---

### 29. LeetCode 693: Binary Number with Alternating Bits（交替位二进制数）

**题目描述**：
给定一个正整数，检查它的二进制表示是否为交替位，即相邻的两个位数是否不同。

**题目分析**：
可以使用位运算来判断交替位。将整数右移一位，并与原整数异或，如果结果全为 `1`（即满足 `n ^ (n >> 1) == 2^k - 1`），则说明该整数是交替位二进制数。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义判断是否为交替位二进制数的函数
    def hasAlternatingBits(self, n: int) -> bool:
        # 计算 n 与右移 1 位后的 n 的异或结果
        xor_result = n ^ (n >> 1)
        # 检查异或结果是否全为 1（即与 2^k - 1 的值进行比较）
        return (xor_result & (xor_result + 1)) == 0

# 时间复杂度：O(1) - 只需进行常数次位运算
# 空间复杂度：O(1) - 只使用了常量级别的额外空间
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(1)，因为整数的位数是固定的（32 位或 64 位），因此最多进行常数次操作。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 30. LeetCode 338: Counting Bits（比特位计数）

**题目描述**：
给定一个非负整数 `num`，对于 `0 ≤ i ≤ num` 范围中的每个数字 `i`，计算其二进制表示中 `1` 的个数，并将它们作为数组返回。

**题目分析**：
可以使用动态规划来解决该问题。对于每个数字 `i`，它的 `1` 的个数可以由以下关系得到：`bits

[i] = bits[i >> 1] + (i & 1)`。即 `i` 的 `1` 的个数等于 `i` 右移一位的 `1` 的个数加上最低位是否为 `1`。

**代码实现**：
```python
# 定义解决方案的类
class Solution:
    # 定义计算比特位计数的函数
    def countBits(self, num: int) -> List[int]:
        # 初始化结果数组，大小为 num + 1
        bits = [0] * (num + 1)
        # 逐个计算 0 到 num 中每个数字的 1 的个数
        for i in range(1, num + 1):
            bits[i] = bits[i >> 1] + (i & 1)
        return bits

# 时间复杂度：O(n) - 逐个计算 0 到 num 中每个数字的 1 的个数
# 空间复杂度：O(n) - 存储比特位计数的结果数组
```

**时间和空间复杂度分析**：
- **时间复杂度**：O(n)，因为需要逐个计算 0 到 `num` 中每个数字的 `1` 的个数。
- **空间复杂度**：O(n)，用于存储比特位计数结果的数组。
