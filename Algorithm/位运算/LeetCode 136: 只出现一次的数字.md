这是 **LeetCode 136: 只出现一次的数字** 的解决方案。它使用了 **位运算中的异或操作** 来高效地找出数组中唯一出现一次的数字，其余数字均出现两次。

---

### LeetCode 136: 只出现一次的数字 (Single Number)

**题目描述**：  
给定一个非空整数数组 `nums`，其中除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

[LeetCode 136: Single Number](https://leetcode.com/problems/single-number/)

---

### 解题思路

1. **使用异或操作**：
   - 异或操作的特点：
     - `a ^ a = 0`：任意数与自身异或结果为 0。
     - `a ^ 0 = a`：任意数与 0 异或结果为其本身。
     - **交换律和结合律**：异或操作满足交换律 `(a ^ b) ^ c = a ^ (b ^ c)`。
   - 利用这些性质，可以将所有数字异或操作在一起，相同的数字会互相抵消变为 `0`，最终的结果就是只出现一次的那个数字。

2. **逐步异或求解**：
   - 初始化 `res` 为第一个数字。
   - 遍历剩余的数字，将 `res` 与每个数字进行异或，最终 `res` 将保留唯一出现的数字。

3. **返回结果**：
   - 遍历完成后，`res` 就是唯一出现一次的数字。

---

### 代码实现

```python
from typing import List

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # 初始值设为第一个元素
        res = nums[0]
        # 从第二个元素开始遍历，进行异或运算
        for n in nums[1:]:
            res ^= n
        # 返回最终结果
        return res
```

---

### 示例讲解：逐步解析示例步骤

假设输入 `nums = [4, 1, 2, 1, 2]`，逐步进行异或操作：

1. **初始化**：`res = 4`

2. **遍历并异或操作**：
   - `res ^= 1`，结果 `res = 4 ^ 1 = 5`
   - `res ^= 2`，结果 `res = 5 ^ 2 = 7`
   - `res ^= 1`，结果 `res = 7 ^ 1 = 6`
   - `res ^= 2`，结果 `res = 6 ^ 2 = 4`

3. **最终结果**：`res = 4`

在此示例中，`4` 是唯一出现一次的数字，所有成对出现的数字在异或操作中被抵消，最终留下的即是唯一的数字 `4`。

---

### 复杂度分析

- **时间复杂度**：O(n)，需要遍历整个数组。
- **空间复杂度**：O(1)，只使用了常量空间来存储 `res`。

---

### 总结

这种方法利用了异或操作的性质，高效地实现了 O(n) 时间复杂度和 O(1) 空间复杂度的解法，是解决此类问题的最佳方法。
