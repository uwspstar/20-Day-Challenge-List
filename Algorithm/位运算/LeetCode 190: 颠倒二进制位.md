### LeetCode 190: 颠倒二进制位 (Reverse Bits)

**题目描述**：  
给定一个 32 位无符号整数 `n`，将其二进制位颠倒，并返回其结果。

[LeetCode 190: Reverse Bits](https://leetcode.com/problems/reverse-bits/)

---

### 解题思路

1. **初始化结果变量**：
   - 使用 `res` 变量存储最终的反转结果，初始值为 `0`。

2. **逐位处理并反转**：
   - 使用循环遍历 `n` 的每一位，共 32 次（因为 `n` 是 32 位的无符号整数）。
   - 在第 `i` 次循环中，通过右移 `i` 位并按位与 `1`（`(n >> i) & 1`）提取 `n` 的第 `i` 位的值。
   - 将提取出的位移到 `res` 中的反向位置 `31 - i`，并将其加到 `res` 中。

3. **返回结果**：
   - 当循环完成后，`res` 就是 `n` 的二进制反转结果，返回 `res`。

---

### 代码实现

```python
class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        for i in range(32):
            # 提取 n 的第 i 位
            bit = (n >> i) & 1
            # 将提取的位移到反向位置 31 - i，然后加到 res 中
            res += (bit << (31 - i))
        return res
```

---

### 逐行解释

1. **初始化结果变量**：
   ```python
   res = 0
   ```
   - `res` 用于存储反转后的结果。

2. **逐位提取和反转**：
   ```python
   for i in range(32):
       bit = (n >> i) & 1
       res += (bit << (31 - i))
   ```
   - `for i in range(32)`：遍历 32 位。
   - `bit = (n >> i) & 1`：提取 `n` 的第 `i` 位。
   - `res += (bit << (31 - i))`：将提取的位 `bit` 移动到反转后的正确位置 `31 - i`，然后累加到 `res` 中。

3. **返回反转结果**：
   ```python
   return res
   ```
   - 返回最终的反转结果 `res`。

---

### 示例讲解：逐步解析示例步骤

假设输入 `n = 00000010100101000001111010011100`（即 `n = 43261596`），以下是代码执行的逐步解释：

1. **初始状态**：
   - `res = 0`

2. **逐位反转**：
   - 第 0 位：`bit = 0`，放入 `res` 的第 31 位，`res = 0`
   - 第 1 位：`bit = 0`，放入 `res` 的第 30 位，`res = 0`
   - 第 2 位：`bit = 1`，放入 `res` 的第 29 位，`res = 100000000000000000000000000000`
   - …（持续进行 32 次，逐位将 `n` 的位反转）

3. **最终结果**：
   - `res = 964176192`（二进制表示为 `00111001011110000010100101000000`）

---

### 复杂度分析

- **时间复杂度**：O(1)，尽管代码遍历了 32 位，但这是一个常数操作，与 `n` 的值无关，因此时间复杂度为 O(1)。
- **空间复杂度**：O(1)，只用了常数空间来存储结果。

---

### 总结

该方法通过逐位提取并反转，实现了 32 位整数的二进制反转操作，是一种简单且高效的解决方案。
