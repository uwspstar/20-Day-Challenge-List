### LeetCode 190: 颠倒二进制位 (Reverse Bits)

**题目描述**：  
给定一个 32 位无符号整数 `n`，将其二进制位颠倒，并返回其结果。

[LeetCode 190: Reverse Bits](https://leetcode.com/problems/reverse-bits/)

---

### 解题思路

1. **初始化结果变量**：
   - 使用 `res` 变量存储最终的反转结果，初始值为 `0`。

2. **逐位处理并反转**：
   - 使用循环遍历 `n` 的每一位，共 32 次（因为 `n` 是 32 位的无符号整数）。
   - 在第 `i` 次循环中，通过右移 `i` 位并按位与 `1`（`(n >> i) & 1`）提取 `n` 的第 `i` 位的值。
   - 将提取出的位移到 `res` 中的反向位置 `31 - i`，并将其加到 `res` 中。

3. **返回结果**：
   - 当循环完成后，`res` 就是 `n` 的二进制反转结果，返回 `res`。
---

在代码中，`(n >> i) & 1` 是一种用于提取整数 `n` 的第 `i` 位的常用操作。它通过位移和按位与运算实现，以下是详细解释：

### 分步解析

1. **右移操作 `(n >> i)`**：
   - `n >> i` 表示将整数 `n` 向右移动 `i` 位。
   - 右移 `i` 位后，`n` 的第 `i` 位将移动到最右边，即第 `0` 位的位置。
   - 例如，对于 `n = 13`（二进制 `1101`）和 `i = 2`，`n >> 2` 的结果是 `11`，即 `3`。原本的第 `2` 位 `1` 被移到最右侧。

2. **按位与操作 `& 1`**：
   - `& 1` 是一种屏蔽操作，保留 `n >> i` 的最低位（即第 `0` 位），将其他位清零。
   - 无论 `n >> i` 结果如何，只有最右边的一位会被保留，其他位会被置为 `0`。
   - 例如，假设右移后的结果是 `11`（二进制），`11 & 1` 的结果是 `1`，因为最低位为 `1`。
   - 如果右移后的结果最低位为 `0`，按位与的结果则为 `0`。

### 具体示例

假设 `n = 13`，即二进制为 `1101`：

- 提取第 `2` 位的值（从右往左数）：
  - 步骤 1：右移 `2` 位，`n >> 2` 得到 `0011`（即 `3`）。
  - 步骤 2：`(0011 & 0001)`，结果是 `1`。
  - 所以，`(13 >> 2) & 1` 的结果为 `1`，即第 `2` 位为 `1`。

- 提取第 `1` 位的值：
  - 步骤 1：右移 `1` 位，`n >> 1` 得到 `0110`（即 `6`）。
  - 步骤 2：`(0110 & 0001)`，结果是 `0`。
  - 所以，`(13 >> 1) & 1` 的结果为 `0`，即第 `1` 位为 `0`。

### 总结

- **`(n >> i) & 1` 的作用**：提取整数 `n` 的第 `i` 位。
- **工作原理**：先通过右移将第 `i` 位移到最右端，再通过按位与操作将其余位清零，只保留 `i` 位的值（`0` 或 `1`）。
  
---

### 代码实现

```python
class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        for i in range(32):
            # 提取 n 的第 i 位
            bit = (n >> i) & 1
            # 将提取的位移到反向位置 31 - i，然后加到 res 中
            res += (bit << (31 - i))
        return res
```

---

### 逐行解释

1. **初始化结果变量**：
   ```python
   res = 0
   ```
   - `res` 用于存储反转后的结果。

2. **逐位提取和反转**：
   ```python
   for i in range(32):
       bit = (n >> i) & 1
       res += (bit << (31 - i))
   ```
   - `for i in range(32)`：遍历 32 位。
   - `bit = (n >> i) & 1`：提取 `n` 的第 `i` 位。
   - `res += (bit << (31 - i))`：将提取的位 `bit` 移动到反转后的正确位置 `31 - i`，然后累加到 `res` 中。

3. **返回反转结果**：
   ```python
   return res
   ```
   - 返回最终的反转结果 `res`。

---

### 示例讲解：逐步解析示例步骤

假设输入 `n = 00000010100101000001111010011100`（即 `n = 43261596`），以下是代码执行的逐步解释：

1. **初始状态**：
   - `res = 0`

2. **逐位反转**：
   - 第 0 位：`bit = 0`，放入 `res` 的第 31 位，`res = 0`
   - 第 1 位：`bit = 0`，放入 `res` 的第 30 位，`res = 0`
   - 第 2 位：`bit = 1`，放入 `res` 的第 29 位，`res = 100000000000000000000000000000`
   - …（持续进行 32 次，逐位将 `n` 的位反转）

3. **最终结果**：
   - `res = 964176192`（二进制表示为 `00111001011110000010100101000000`）

---

### 复杂度分析

- **时间复杂度**：O(1)，尽管代码遍历了 32 位，但这是一个常数操作，与 `n` 的值无关，因此时间复杂度为 O(1)。
- **空间复杂度**：O(1)，只用了常数空间来存储结果。

---

### 总结

该方法通过逐位提取并反转，实现了 32 位整数的二进制反转操作，是一种简单且高效的解决方案。
