### 题目：找到数组中出现频率最高的 K 个元素 (Top K Frequent Elements)

---

### **代码实现**：
```python
from typing import List

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        res = []  # 用于存储结果
        map_n = {}  # 用于统计每个数字出现的频率
        bkt = [[] for _ in range(len(nums) + 1)]  # 桶排序，索引代表频率
        
        # 统计每个数字的频率
        for n in nums:
            map_n[n] = map_n.get(n, 0) + 1
        
        # 将每个数字按照其频率放入对应的桶
        for key, val in map_n.items():
            bkt[val].append(key)

        # 从高频到低频遍历桶，找到前 K 个频率最高的元素
        for i in range(len(bkt) - 1, 0, -1):
            for num in bkt[i]:
                res.append(num)
                if len(res) == k:  # 找到 K 个元素后返回
                    return res
        
        return res  # 如果未提前返回，返回结果
```

---

### **时间和空间复杂度分析**：

#### **时间复杂度**：
1. **统计频率**：遍历数组一次，时间复杂度为 \( O(n) \)，其中 \( n \) 是数组的长度。
2. **桶排序**：
   - 遍历 `map_n`，将元素放入对应的桶，时间复杂度为 \( O(n) \)。
   - 遍历桶，从高频到低频查找 \( k \) 个元素，最坏情况下也为 \( O(n) \)。
3. **总时间复杂度**：\( O(n) \)。

#### **空间复杂度**：
- 使用字典 `map_n` 存储每个数字的频率，占用 \( O(n) \) 空间。
- 使用桶排序列表 `bkt`，长度为 \( n + 1 \)，占用 \( O(n) \) 空间。
- **总空间复杂度**：\( O(n) \)。

---

### **示例运行步骤**：

#### **输入**：
```python
nums = [1, 1, 1, 2, 2, 3]
k = 2
```

#### **运行过程**：

1. **统计频率**：
   - 遍历数组 `nums`：
     - 数字 `1` 出现 3 次，数字 `2` 出现 2 次，数字 `3` 出现 1 次。
   - 频率字典 `map_n`：
     ```python
     map_n = {1: 3, 2: 2, 3: 1}
     ```

2. **桶排序**：
   - 初始化桶列表：
     ```python
     bkt = [[], [], [], [], [], [], []]  # 长度为 len(nums) + 1
     ```
   - 根据频率将数字放入对应的桶：
     ```python
     bkt = [[], [3], [2], [1], [], [], []]
     ```

3. **从高频到低频查找**：
   - 从桶的高索引（频率高）向低索引遍历：
     - 桶 `bkt[3]` 包含数字 `[1]`，加入结果：
       ```python
       res = [1]
       ```
     - 桶 `bkt[2]` 包含数字 `[2]`，加入结果：
       ```python
       res = [1, 2]
       ```
   - 找到前 `k = 2` 个频率最高的数字后，返回结果。

#### **输出**：
```python
[1, 2]
```

---

### **总结**：
- **核心思路**：
  - 使用字典统计频率。
  - 利用桶排序，将相同频率的数字分组。
  - 从高频到低频查找前 `k` 个元素。
- **优点**：
  - 时间复杂度低，适合处理大规模数据。
  - 避免了直接排序的开销。

---

### **示例输出**：
```python
输入: nums = [1, 1, 1, 2, 2, 3], k = 2
输出: [1, 2]

输入: nums = [4, 4, 4, 4, 6, 6, 6, 5], k = 2
输出: [4, 6]
```

---

在桶排序中使用 **`len(nums) + 1`** 的原因是为了确保桶的数量足够存储 **所有可能的频率**，包括从频率为 `0` 到频率为 `len(nums)` 的情况。

### **详细解释**：

#### 1. **频率的范围**
- 数组 `nums` 的频率分布：
  - 一个元素的最大频率是 `len(nums)`（当所有元素相同时）。
  - 一个元素的最小频率是 `1`（元素只出现一次）。
- 因此，需要为每个可能的频率准备一个桶，桶的索引表示频率。

#### 2. **为什么是 `len(nums) + 1`？**
- 桶列表的索引范围是从 `0` 到 `len(nums)`，索引总数为 `len(nums) + 1`。
- 例如：
  - 如果数组长度是 `6`，则最大频率是 `6`，需要 `0` 到 `6` 共 **7 个桶**。

#### 3. **代码中的实现**
桶的初始化：
```python
bkt = [[] for _ in range(len(nums) + 1)]
```
- 这段代码创建了 `len(nums) + 1` 个空列表。
- 每个空列表对应某个频率。例如：
  - `bkt[1]` 存储出现 1 次的元素。
  - `bkt[2]` 存储出现 2 次的元素。
  - `bkt[len(nums)]` 存储出现最多次数的元素。

#### 4. **避免数组越界**
- 如果只初始化 `len(nums)` 个桶，当某个元素频率达到 `len(nums)` 时，会导致数组越界错误。
- 通过 `len(nums) + 1`，确保即使所有元素都相同，也不会越界。

---

### **示例说明**
假设输入数组为：
```python
nums = [1, 1, 1, 2, 2, 3]  # 长度 len(nums) = 6
```

1. **统计频率**：
   - 元素 `1` 的频率是 `3`。
   - 元素 `2` 的频率是 `2`。
   - 元素 `3` 的频率是 `1`。

2. **创建桶数组**：
   ```python
   bkt = [[], [], [], [], [], [], []]  # 长度为 len(nums) + 1 = 7
   ```

3. **将元素放入桶**：
   - 频率为 `3` 的元素放入 `bkt[3]`：`bkt = [[], [], [], [1], [], [], []]`
   - 频率为 `2` 的元素放入 `bkt[2]`：`bkt = [[], [], [2], [1], [], [], []]`
   - 频率为 `1` 的元素放入 `bkt[1]`：`bkt = [[], [3], [2], [1], [], [], []]`

4. **从高频到低频查找**：
   - 遍历 `bkt` 索引 `6 → 1`，即可找到频率最高的 `k` 个元素。

---

### **总结**
- **`+1` 的必要性**：
  - 确保最大频率 `len(nums)` 有对应的桶。
  - 避免数组越界。
- **使用桶排序的优点**：
  - 桶索引直接对应频率，无需排序，节省时间复杂度。
