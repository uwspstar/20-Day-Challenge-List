### LeetCode 239: Sliding Window Maximum（滑动窗口最大值）
[LeetCode 239](https://leetcode.com/problems/sliding-window-maximum/)

**题目描述**：
给定一个大小为 `n` 的整数数组 `nums` 和一个大小为 `k` 的窗口，找到每个窗口中最大值的数组。

**代码实现**：
```python
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ans = []  # 存储结果的列表
        q = deque()  # 用于存储当前窗口内可能成为最大值的索引
        l = r = 0  # 初始化左右指针

        # 右指针遍历数组 nums
        while r < len(nums):
            # 如果当前元素大于队列中的元素，从队列尾部移除这些元素
            while q and nums[q[-1]] < nums[r]:
                q.pop()
            
            # 将当前索引加入队列
            q.append(r)

            # 如果队列最左侧的元素不在窗口范围内，移除它
            if l > q[0]:
                q.popleft()

            # 当窗口大小达到 k 时，加入最大值到结果中
            if (r + 1) >= k:
                ans.append(nums[q[0]])  # 当前窗口最大值为队列最左侧的元素
                l += 1  # 移动左指针

            r += 1  # 移动右指针
        
        return ans
```

### 代码解释

1. **初始化**：
   - 使用双端队列 `q` 来存储当前窗口中可能成为最大值的索引。
   - `ans` 用于存储每个窗口的最大值。
   - `l` 和 `r` 分别为左、右指针，用于控制窗口的边界。

2. **维护双端队列**：
   - 当 `nums[r]` 大于 `q` 中存储的元素时，将 `q` 中的较小元素弹出，因为它们不可能是当前或未来窗口的最大值。
   - 将 `r` 加入到队列中。

3. **移除过期元素**：
   - 如果队列最左侧的索引小于左指针 `l`，说明该元素已经不在当前窗口范围内，需将其移除。

4. **更新结果**：
   - 当窗口大小达到 `k` 时，`q[0]` 即为当前窗口的最大值，将其加入到结果中。
   - 同时，左指针 `l` 右移，保持窗口大小为 `k`。

5. **返回结果**：
   - 最终返回所有窗口的最大值列表 `ans`。

### 复杂度分析

- **时间复杂度**：O(n)
  - 每个元素在队列中被添加和删除各一次，因此整体时间复杂度为 O(n)。
  
- **空间复杂度**：O(k)
  - 最坏情况下，队列中可能存储 `k` 个元素，空间复杂度为 O(k)。

### 示例讲解

#### 示例 1
```
输入: nums = [1,3,-1,-3,5,3,6,7], k = 3
输出: [3,3,5,5,6,7]
解释: 
滑动窗口为:
[1, 3, -1] -> 最大值为 3
[3, -1, -3] -> 最大值为 3
[-1, -3, 5] -> 最大值为 5
[-3, 5, 3] -> 最大值为 5
[5, 3, 6] -> 最大值为 6
[3, 6, 7] -> 最大值为 7
```

- 使用双端队列维护窗口内的最大值索引，依次得到各个窗口的最大值。

### 总结

- **双端队列**（deque）是一种高效解决滑动窗口问题的结构，因为它能在常数时间内完成元素的插入和删除。
- 通过维护窗口内的最大值索引，可以在 O(n) 时间复杂度内找到所有窗口的最大值。
