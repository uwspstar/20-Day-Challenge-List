### LeetCode 76: Minimum Window Substring（最小覆盖子串）

**题目描述**：
给定一个字符串 `s` 和一个字符串 `t`，找到 `s` 中最小的子串，使得这个子串中包含 `t` 中所有字符（包括重复字符）。如果不存在这样的子串，则返回空字符串 `""`。

**代码实现**：
```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        # 初始化左指针、目标字符频率表、窗口字符频率表
        l = 0
        t_map, window = {}, {}

        # 统计目标字符串 t 中字符的频率
        for c in t:
            t_map[c] = t_map.get(c, 0) + 1
        
        # 初始化 '已满足条件的字符数量' 和 '需要满足的字符种类数'
        have, need = 0, len(t_map)
        res, res_len = [-1, -1], float("inf")

        # 右指针遍历字符串 s
        for r in range(len(s)):
            c = s[r]
            window[c] = window.get(c, 0) + 1

            # 如果当前字符满足了 t_map 中的要求
            if c in t_map and window[c] == t_map[c]:
                have += 1

            # 当满足条件的字符数量等于需要的字符种类数时，尝试收缩左指针
            while have == need:
                # 更新最小窗口
                if (r - l + 1) < res_len:
                    res = [l, r]
                    res_len = (r - l + 1)

                # 减少窗口中左指针字符的频率
                window[s[l]] -= 1

                # 如果减少后不再满足 t_map 中的要求，已满足条件的字符数量减 1
                if s[l] in t_map and window[s[l]] < t_map[s[l]]:
                    have -= 1
                
                # 左指针右移，尝试收缩窗口
                l += 1
        
        l, r = res
        
        # 如果找到了最小窗口，返回该子串；否则返回空字符串
        return s[l: r+1] if res_len != float("inf") else ""
```

### 题目分析

- 要在字符串 `s` 中找到一个最小的子串，使其包含 `t` 中的所有字符。这个问题可以通过**滑动窗口**方法来解决。
- 滑动窗口可以在 O(n) 时间内完成遍历，适合处理大规模字符串。

### 解决方案详解

#### 1. **初始化**
- 使用两个字典：
  - `t_map`：存储目标字符串 `t` 中字符的频率。
  - `window`：存储当前窗口中字符的频率。

#### 2. **统计目标字符串的字符频率**
```python
for c in t:
    t_map[c] = t_map.get(c, 0) + 1
```
- 统计字符串 `t` 中每个字符的频率，存储在 `t_map` 中。

#### 3. **滑动窗口遍历字符串 `s`**
- 右指针 `r` 遍历字符串 `s`。
- 每次遇到一个字符，将其加入窗口频率表 `window`，如果该字符满足 `t_map` 的要求，则增加 `have`。
- 当 `have == need` 时，说明当前窗口已经满足条件，尝试通过移动左指针 `l` 收缩窗口。

#### 4. **更新最小窗口**
- 如果当前窗口长度小于 `res_len`，更新结果子串的起始和结束索引 `res` 及最小长度 `res_len`。

#### 5. **收缩窗口**
- 当左指针移动时，减少当前窗口字符的频率。如果该字符频率小于 `t_map` 中的要求，则减少 `have`，表示不再满足条件。

#### 6. **返回结果**
- 根据最小窗口的起始和结束索引，返回结果子串。如果未找到有效子串，返回空字符串。

### 复杂度分析

- **时间复杂度**：O(n)
  - 滑动窗口的两指针（左指针和右指针）最多各遍历字符串 `s` 一次，因此时间复杂度为 O(n)，其中 n 是字符串 `s` 的长度。
  
- **空间复杂度**：O(m)
  - 需要额外的空间来存储两个字典 `t_map` 和 `window`，其中 m 是字符串 `t` 中不同字符的数量。

### 示例讲解

#### 示例 1
```
输入: s = "ADOBECODEBANC", t = "ABC"
输出: "BANC"
解释: "BANC" 是最小覆盖子串，包含了 'A'、'B' 和 'C'。
```
- 初始窗口："ADOBEC" 满足条件，长度为 6。
- 收缩窗口至 "BECODEBA"，不满足条件。
- 最终找到的最小覆盖子串为 "BANC"。

#### 示例 2
```
输入: s = "a", t = "a"
输出: "a"
解释: 字符串 "a" 包含了字符 'a'。
```

#### 示例 3
```
输入: s = "a", t = "aa"
输出: ""
解释: "s" 中没有足够的字符 'a'，无法覆盖 "t"。
```

### 总结

- **滑动窗口法**非常适合解决最小覆盖子串问题，它可以在 O(n) 时间内找到最优解。
- 通过使用两个字典来管理目标字符和当前窗口字符的频率，可以高效地判断当前窗口是否满足条件。
- 这种方法在处理大规模字符串问题时效果较佳，是解决最小窗口问题的经典方法。
