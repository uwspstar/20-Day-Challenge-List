### LRU 缓存实现 (Least Recently Used Cache)

---

### **代码说明**
使用 Python 的 `OrderedDict` 实现 LRU 缓存机制。`OrderedDict` 是字典的一个子类，它可以保持键值对的插入顺序，从而方便实现 "最近最少使用" 的缓存。

---

### **代码实现**
```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        # 初始化一个有序字典用于存储缓存
        self.cache = OrderedDict()
        self.cap = capacity  # 设置缓存容量

    def get(self, key: int) -> int:
        if key not in self.cache:  # 如果键不存在，返回 -1
            return -1
        # 将访问的键移动到末尾，表示最近使用
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        # 如果键已经存在，更新值并将其移动到末尾
        if key in self.cache:
            self.cache.move_to_end(key)
        # 添加或更新键值对
        self.cache[key] = value
        # 如果缓存超出容量，移除最旧的键值对
        if len(self.cache) > self.cap:
            self.cache.popitem(last=False)  # 移除最前面的键值对
```

---

### **时间复杂度**
1. **`get` 操作**：
   - 查找键的时间复杂度为 \( O(1) \)。
   - 调用 `move_to_end` 将键移到末尾的时间复杂度为 \( O(1) \)。
   - 总时间复杂度为 **\( O(1) \)**。

2. **`put` 操作**：
   - 添加或更新键值对的时间复杂度为 \( O(1) \)。
   - 如果缓存超出容量，调用 `popitem` 移除最旧的键值对，时间复杂度为 \( O(1) \)。
   - 总时间复杂度为 **\( O(1) \)**。

3. **空间复杂度**：
   - 存储最多 `capacity` 个键值对，空间复杂度为 **\( O(capacity) \)**。

---

### **运行示例**
#### 输入操作：
```python
lru = LRUCache(2)
lru.put(1, 1)  # 缓存内容：{1=1}
lru.put(2, 2)  # 缓存内容：{1=1, 2=2}
print(lru.get(1))  # 返回 1，缓存内容：{2=2, 1=1}
lru.put(3, 3)  # 超过容量，移除最少使用的键 2，缓存内容：{1=1, 3=3}
print(lru.get(2))  # 返回 -1（未找到）
lru.put(4, 4)  # 超过容量，移除最少使用的键 1，缓存内容：{3=3, 4=4}
print(lru.get(1))  # 返回 -1（未找到）
print(lru.get(3))  # 返回 3，缓存内容：{4=4, 3=3}
print(lru.get(4))  # 返回 4，缓存内容：{3=3, 4=4}
```

#### 输出：
```python
1
-1
-1
3
4
```

---

### **核心逻辑解析**
1. **`get` 方法**：
   - 如果键存在，则将该键移动到末尾表示最近使用。
   - 如果键不存在，则返回 `-1`。

2. **`put` 方法**：
   - 如果键已经存在，则更新其值并将其移动到末尾。
   - 如果键不存在，则直接插入。
   - 如果缓存容量超过限制，移除最前面的键值对（最久未使用的键）。

---

### **示例运行过程**

1. **初始化**：
   ```python
   lru = LRUCache(2)  # 容量为 2
   ```

2. **操作 1：`put(1, 1)`**：
   - 添加键值对 `{1=1}`。
   - 缓存内容：`{1=1}`。

3. **操作 2：`put(2, 2)`**：
   - 添加键值对 `{2=2}`。
   - 缓存内容：`{1=1, 2=2}`。

4. **操作 3：`get(1)`**：
   - 键 `1` 存在，返回 `1`，并将键 `1` 移动到末尾。
   - 缓存内容：`{2=2, 1=1}`。

5. **操作 4：`put(3, 3)`**：
   - 添加键值对 `{3=3}`，超出容量，移除最久未使用的键 `2`。
   - 缓存内容：`{1=1, 3=3}`。

6. **操作 5：`get(2)`**：
   - 键 `2` 不存在，返回 `-1`。

7. **操作 6：`put(4, 4)`**：
   - 添加键值对 `{4=4}`，超出容量，移除最久未使用的键 `1`。
   - 缓存内容：`{3=3, 4=4}`。

8. **操作 7：`get(1)`**：
   - 键 `1` 不存在，返回 `-1`。

9. **操作 8：`get(3)`**：
   - 键 `3` 存在，返回 `3`，并将键 `3` 移动到末尾。
   - 缓存内容：`{4=4, 3=3}`。

10. **操作 9：`get(4)`**：
    - 键 `4` 存在，返回 `4`，并将键 `4` 移动到末尾。
    - 缓存内容：`{3=3, 4=4}`。

---

### **总结**
- **`OrderedDict` 的核心功能**：
  - 保持字典的插入顺序。
  - 提供 `move_to_end` 和 `popitem` 方法，简化 LRU 缓存的实现。
- **时间复杂度**：
  - 所有操作均为 \( O(1) \)，非常高效。
- **适用场景**：
  - 用于实现具有容量限制的缓存系统，例如 Web 浏览器的页面缓存或内存管理中的缓存。
