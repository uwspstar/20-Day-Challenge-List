# 排序

冒泡排序（Bubble Sort）是一种基础的排序算法，其主要思想是：通过重复遍历待排序的数组，每次比较相邻的两个元素，如果前一个比后一个大，就交换它们的位置。这一过程将较大的元素逐步“冒泡”到数组的末尾，最终完成排序。

### 算法步骤

1. **外层循环**：控制遍历的轮数。每一轮遍历，最大的元素会“冒泡”到当前未排序部分的末尾。
2. **内层循环**：从数组的第一个元素开始，逐一比较相邻的两个元素，如果前者大于后者，就交换它们。
3. **提前退出**：如果某一轮遍历没有发生交换，说明数组已经有序，可以提前退出循环。

### 代码实现

```python
def bubble_sort(arr):
    n = len(arr)
    # 遍历整个数组
    for i in range(n):
        # 标记是否发生了交换
        swapped = False
        # 内层循环逐一比较相邻的元素
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                # 交换元素
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        # 如果没有发生交换，提前退出
        if not swapped:
            break
    return arr
```

### 复杂度分析

- **时间复杂度**：O(n²)
  - 最坏情况下需要进行 n(n-1)/2 次比较和交换，因此时间复杂度为 O(n²)。
  - 在最佳情况下，如果数组已排序，内层循环无需交换，时间复杂度为 O(n)。
- **空间复杂度**：O(1)
  - 冒泡排序是原地排序算法，不需要额外的存储空间。

### 示例讲解

假设我们对数组 `[64, 34, 25, 12, 22, 11, 90]` 进行冒泡排序，过程如下：

1. 初始数组：`[64, 34, 25, 12, 22, 11, 90]`
2. 第 1 轮遍历：
   - 比较 64 和 34，交换 → `[34, 64, 25, 12, 22, 11, 90]`
   - 比较 64 和 25，交换 → `[34, 25, 64, 12, 22, 11, 90]`
   - 比较 64 和 12，交换 → `[34, 25, 12, 64, 22, 11, 90]`
   - 比较 64 和 22，交换 → `[34, 25, 12, 22, 64, 11, 90]`
   - 比较 64 和 11，交换 → `[34, 25, 12, 22, 11, 64, 90]`
   - 比较 64 和 90，无需交换
   - 第 1 轮结束，最大元素 90 已经在最后位置

3. 第 2 轮遍历：
   - 继续上述过程，将次大的元素“冒泡”到倒数第二位置。
   - 每轮遍历未排序部分的元素数减一。
   - 重复以上过程，直到数组有序。

### 总结

- 冒泡排序简单易理解，但时间复杂度较高，适用于小规模数据。
- 冒泡排序是**稳定排序**，相等的元素顺序不会改变。
- 如果数组接近有序，冒泡排序的提前退出机制会提高效率。


---

### 选择排序（Selection Sort）

是一种简单直观的排序算法。它的基本思想是：在未排序的部分中找到最小的元素，将其放在已排序部分的末尾。这个过程会不断重复，直到整个列表有序。

### 算法步骤

1. **初始化**：从列表的第一个元素开始。
2. **选择最小元素**：在当前未排序部分中找到最小的元素。
3. **交换**：将找到的最小元素与当前未排序部分的第一个元素交换位置。
4. **重复**：从下一个位置开始，重复步骤 2 和 3，直到排序完成。

### 代码实现

```python
def selection_sort(arr):
    n = len(arr)
    # 遍历整个数组
    for i in range(n):
        # 假设当前索引 i 的元素是最小值
        min_index = i
        # 从 i+1 到 n 查找未排序部分中的最小元素
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        # 将最小元素和当前元素交换
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr
```

### 复杂度分析

- **时间复杂度**：O(n²)
  - 外层循环运行 `n` 次，内层循环在最坏情况下运行 `n-1`、`n-2`、...、`1` 次。因此总的时间复杂度为 O(n²)。
- **空间复杂度**：O(1)
  - 选择排序是原地排序算法，不需要额外的存储空间。

### 示例讲解

假设我们对数组 `[64, 25, 12, 22, 11]` 进行选择排序，过程如下：

1. 初始数组：`[64, 25, 12, 22, 11]`
2. 第 1 次遍历（找到最小值 11，放在第一个位置）：
   - `11` 和 `64` 交换，结果为 `[11, 25, 12, 22, 64]`
3. 第 2 次遍历（找到最小值 12，放在第二个位置）：
   - `12` 和 `25` 交换，结果为 `[11, 12, 25, 22, 64]`
4. 第 3 次遍历（找到最小值 22，放在第三个位置）：
   - `22` 和 `25` 交换，结果为 `[11, 12, 22, 25, 64]`
5. 第 4 次遍历（找到最小值 25，已经在正确位置，不交换）：
   - 结果为 `[11, 12, 22, 25, 64]`
6. 最终排序完成：`[11, 12, 22, 25, 64]`

### 总结

- 选择排序的优势在于简单直观，适用于小规模的数据。
- 选择排序是**不稳定排序**，因为相同元素可能会交换顺序。

---
插入排序（Insertion Sort）是一种简单直观的排序算法，其主要思想是：将数组分为已排序和未排序两部分，每次从未排序部分中取出一个元素，将其插入到已排序部分的合适位置，使得已排序部分仍然有序。

### 算法步骤

1. **初始化**：假设第一个元素是已排序部分，从第二个元素开始处理。
2. **遍历未排序部分**：从左到右逐一取出每个元素，将其插入到前面的已排序部分的正确位置。
3. **插入过程**：将当前元素与已排序部分的元素从右到左比较，如果当前元素小于已排序部分的元素，就将已排序元素向右移动，直到找到合适位置。
4. **重复**：重复此过程，直到所有元素都已排序。

### 代码实现

```python
def insertion_sort(arr):
    # 遍历未排序部分
    for i in range(1, len(arr)):
        # 取出当前元素
        current = arr[i]
        # 找到插入位置
        j = i - 1
        # 向右移动大于当前元素的已排序元素
        while j >= 0 and arr[j] > current:
            arr[j + 1] = arr[j]
            j -= 1
        # 将当前元素插入合适位置
        arr[j + 1] = current
    return arr
```

### 复杂度分析

- **时间复杂度**：O(n²)
  - 最坏情况下（数组是倒序的），每个元素都需要与前面的元素比较，因此总的时间复杂度为 O(n²)。
  - 最佳情况下（数组已排序），每个元素只需比较一次，时间复杂度为 O(n)。
- **空间复杂度**：O(1)
  - 插入排序是原地排序算法，不需要额外的存储空间。

### 示例讲解

假设我们对数组 `[12, 11, 13, 5, 6]` 进行插入排序，过程如下：

1. 初始数组：`[12, 11, 13, 5, 6]`
2. 第 1 步（`i = 1`）：取出 `11`
   - 与 `12` 比较，`11 < 12`，将 `12` 向右移动。
   - 插入 `11` 到索引 0 处，数组变为 `[11, 12, 13, 5, 6]`
3. 第 2 步（`i = 2`）：取出 `13`
   - `13 > 12`，无需移动，插入 `13` 到原位置。
4. 第 3 步（`i = 3`）：取出 `5`
   - 与 `13`、`12`、`11` 逐一比较并右移它们。
   - 插入 `5` 到索引 0 处，数组变为 `[5, 11, 12, 13, 6]`
5. 第 4 步（`i = 4`）：取出 `6`
   - 与 `13`、`12`、`11` 逐一比较并右移它们。
   - 插入 `6` 到索引 1 处，数组变为 `[5, 6, 11, 12, 13]`

最终排序完成：`[5, 6, 11, 12, 13]`

### 总结

- **插入排序**适用于数据量小或部分有序的情况，算法实现简单，效率较高。
- 插入排序是**稳定排序**，即相同元素的相对位置不会改变。


