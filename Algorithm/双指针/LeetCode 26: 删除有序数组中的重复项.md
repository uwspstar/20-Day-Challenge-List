## Title: [LeetCode 26: 删除有序数组中的重复项 (Remove Duplicates from Sorted Array)](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)

---

## 问题

给定一个按非递减顺序排列的整数数组 `nums`，请你**原地**删除重复出现的元素，使得每个元素只出现一次，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在**原地**修改输入数组，并在使用 O(1) 额外空间的条件下完成。

**注意**：返回的数组长度的前部分元素应该是删除重复项后的新数组，数组的其余部分可以忽略。

### 示例 1:

```
输入: nums = [1,1,2]
输出: 2, nums = [1,2,_]
解释: 函数应该返回新的长度 2，并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。
```

### 示例 2:

```
输入: nums = [0,0,1,1,1,2,2,3,3,4]
输出: 5, nums = [0,1,2,3,4,_]
解释: 函数应该返回新的长度 5，并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。
```

---

## 解题思路

这个问题要求我们在**原地**删除有序数组中的重复元素，并且返回新数组的长度。由于数组已经按非递减顺序排列，因此可以使用 **双指针** 技巧来解决此问题。

### 双指针法

- 我们使用两个指针 `i` 和 `j` 来遍历数组：
  - `i` 作为慢指针，指向存储去重结果的位置。
  - `j` 作为快指针，扫描整个数组。
- 当 `nums[j]` 不等于 `nums[i]` 时，说明找到了一个新的元素，可以将其存储在 `i + 1` 的位置。
- 继续移动 `j` 指针遍历整个数组。

---

### 代码实现：
```python
class Solution:
    # [0,0,1,1,1,2,2,3,3,4]
    #    1     r
    #    l
    def removeDuplicates(self, nums: List[int]) -> int:
        l, r = 0, 1
        while r < len(nums):
            if nums[l] == nums[r]:
                r += 1
            else:
                l += 1
                nums[l] = nums[r]
                r += 1
                
        return  l + 1 

```

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if not nums:  # 处理空数组的特殊情况
            return 0

        i = 0  # 慢指针，指向去重后的最后一个元素位置

        for j in range(1, len(nums)):
            if nums[j] != nums[i]:  # 当快指针发现一个不同的元素
                i += 1  # 慢指针向前移动
                nums[i] = nums[j]  # 更新去重后的数组
        return i + 1  # 返回去重后数组的长度
```

---

### 代码解释：

1. **处理空数组**：
   - 首先检查输入的数组是否为空。如果 `nums` 为空，直接返回 `0`。

2. **初始化指针**：
   - `i` 为慢指针，初始时指向数组的第一个元素位置。
   - `j` 为快指针，从索引 `1` 开始遍历数组。

3. **遍历数组**：
   - 当 `nums[j] != nums[i]` 时，说明找到了一个新的非重复元素。
   - 将慢指针 `i` 向前移动一位，并将快指针指向的元素 `nums[j]` 复制到 `nums[i]` 位置。

4. **返回去重后的数组长度**：
   - 最后，返回 `i + 1`，即去重后数组的长度。

---

### 复杂度分析：

- **时间复杂度**：O(n)，其中 `n` 是数组的长度。我们只遍历数组一次。
  
- **空间复杂度**：O(1)，我们只使用了常量的额外空间，没有使用额外数组。

---

### 示例讲解：

#### 示例 1:

```
输入: nums = [1,1,2]
```

- `i = 0`，`j = 1`，发现 `nums[j] == nums[i]`，所以不移动慢指针。
- `j = 2`，发现 `nums[j] != nums[i]`，将 `i` 增加到 1，并将 `nums[2]` 的值 `2` 复制到 `nums[1]`。
- 最终数组为 `[1, 2, _]`，返回长度 `2`。

#### 示例 2:

```
输入: nums = [0,0,1,1,1,2,2,3,3,4]
```

- `i = 0`，`j = 1`，`nums[j] == nums[i]`，慢指针不动。
- 当 `j = 2` 时，`nums[j] != nums[i]`，将 `i` 增加到 1，并将 `nums[2]` 赋值到 `nums[1]`。
- 重复该过程，最终数组变为 `[0, 1, 2, 3, 4, _]`，返回长度 `5`。

---

### 总结

- **中文**：通过使用双指针技巧，我们可以高效地在原地删除有序数组中的重复元素，并且返回去重后数组的长度。时间复杂度为 O(n)，空间复杂度为 O(1)。

---

### 推荐相似问题：

1. [LeetCode 27: 移除元素](https://leetcode.com/problems/remove-element/)
2. [LeetCode 80: 删除有序数组中的重复项 II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)
3. [LeetCode 283: 移动零](https://leetcode.com/problems/move-zeroes/)
4. [LeetCode 88: 合并两个有序数组](https://leetcode.com/problems/merge-sorted-array/)
