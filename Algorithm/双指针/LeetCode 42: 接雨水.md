### LeetCode 42: 接雨水

https://leetcode.com/problems/trapping-rain-water/

---

### 题目描述：

给定一个非负整数数组 `height`，数组中的每个元素表示墙的高度，每个柱子之间可以积水。你需要计算出这些柱子间能积多少雨水。

#### 示例：

```python
输入: height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

在这个例子中，柱子之间可以积水的区域总面积为 6。

---

### 解题思路：

使用**双指针法**，从左右两端向中间移动指针，动态维护当前左右两边的最大高度，来计算可以积水的区域。

#### 具体步骤：

1. **初始化指针**：使用两个指针，左指针 `l` 从左边开始，右指针 `r` 从右边开始。分别记录左边的最大高度 `l_max` 和右边的最大高度 `r_max`。
2. **移动指针**：每次比较左右指针的最大高度，选择较小的一侧进行处理。如果左侧高度较小，则移动左指针并更新左侧最大高度；反之移动右指针并更新右侧最大高度。
3. **计算积水量**：每次移动指针后，计算当前位置的积水量，并累加到总结果中。
4. **结束循环**：当左右指针相遇时，整个过程结束，返回积水总量。

---

### 代码实现（附详细注释）：

```python
from typing import List

class Solution:
    def trap(self, height: List[int]) -> int:
        # 如果高度数组为空，则无法积水，直接返回 0
        if not height:
            return 0

        # 初始化左右指针，左指针指向数组开头，右指针指向数组末尾
        l, r = 0, len(height) - 1
        # 分别初始化左右指针对应的最大高度
        l_max, r_max = height[l], height[r]

        # 初始化积水总量
        res = 0

        # 当左指针小于右指针时，继续计算积水
        while l < r:
            # 如果左边的最大高度小于右边的最大高度
            if l_max < r_max:
                # 移动左指针
                l += 1
                # 更新左指针处的最大高度
                l_max = max(l_max, height[l])
                # 计算当前位置的积水量，并累加到总结果中
                res += l_max - height[l]
            else:
                # 如果右边的最大高度小于等于左边的最大高度
                # 移动右指针
                r -= 1
                # 更新右指针处的最大高度
                r_max = max(r_max, height[r])
                # 计算当前位置的积水量，并累加到总结果中
                res += r_max - height[r]

        # 返回积水的总量
        return res
```

---

### 代码注释：

1. **初始化**：
   - 如果 `height` 数组为空，直接返回 0。
   - 使用 `l` 和 `r` 指针分别指向数组的最左端和最右端，初始化 `l_max` 和 `r_max` 为左右两端的高度。
   - 使用 `res` 来保存总积水量，初始化为 0。

2. **双指针移动**：
   - 当左指针 `l` 小于右指针 `r` 时，进入循环。
   - 如果左指针的最大高度 `l_max` 小于右指针的最大高度 `r_max`，说明左边的柱子限制了积水量，移动左指针。
   - 更新左边的最大高度 `l_max`，并计算当前位置的积水量。
   - 如果右边的最大高度 `r_max` 小于或等于左边的最大高度，说明右边的柱子限制了积水量，移动右指针。
   - 更新右边的最大高度 `r_max`，并计算当前位置的积水量。

3. **循环结束**：
   - 当左右指针相遇时，所有积水量已计算完毕，返回结果。

---

### 复杂度分析：

- **时间复杂度**：O(n)，其中 `n` 是数组 `height` 的长度。每个元素最多访问一次。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 示例分析：

对于输入 `height = [0,1,0,2,1,0,1,3,2,1,2,1]`：

1. 初始化左右指针：`l = 0`，`r = 11`，`l_max = 0`，`r_max = 1`。
2. 比较 `l_max` 和 `r_max`，由于 `l_max < r_max`，移动左指针并更新 `l_max`。
3. 移动指针并逐步计算积水，最终得到积水总量 6。

---

### 总结：

通过双指针法，我们可以一次遍历解决这个问题。利用两个指针动态维护左右两边的最大高度，保证每次只处理限制积水量的一侧，从而在 O(n) 的时间复杂度下计算出积水总量，并且只使用了常量空间。
