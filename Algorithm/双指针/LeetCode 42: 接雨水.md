### LeetCode 42: 接雨水

https://leetcode.com/problems/trapping-rain-water/

---

### 题目描述：

给定一个非负整数数组 `height`，数组中的每个元素表示墙的高度，每个柱子之间可以积水。你需要计算出这些柱子间能积多少雨水。

#### 示例：

```python
输入: height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

在这个例子中，柱子之间可以积水的区域总面积为 6。

---

### 解题思路：

使用**双指针法**，从左右两端向中间移动指针，动态维护当前左右两边的最大高度，来计算可以积水的区域。

#### 具体步骤：

1. **初始化指针**：使用两个指针，左指针 `l` 从左边开始，右指针 `r` 从右边开始。分别记录左边的最大高度 `l_max` 和右边的最大高度 `r_max`。
2. **移动指针**：每次比较左右指针的最大高度，选择较小的一侧进行处理。如果左侧高度较小，则移动左指针并更新左侧最大高度；反之移动右指针并更新右侧最大高度。
3. **计算积水量**：每次移动指针后，计算当前位置的积水量，并累加到总结果中。
4. **结束循环**：当左右指针相遇时，整个过程结束，返回积水总量。

---

### 代码实现（附详细注释）：

```python
from typing import List

class Solution:
    def trap(self, height: List[int]) -> int:
        # 如果高度数组为空，则无法积水，直接返回 0
        if not height:
            return 0

        # 初始化左右指针，左指针指向数组开头，右指针指向数组末尾
        l, r = 0, len(height) - 1
        # 分别初始化左右指针对应的最大高度
        l_max, r_max = height[l], height[r]

        # 初始化积水总量
        res = 0

        # 当左指针小于右指针时，继续计算积水
        while l < r:
            # 如果左边的最大高度小于右边的最大高度
            if l_max < r_max:
                # 移动左指针
                l += 1
                # 更新左指针处的最大高度
                l_max = max(l_max, height[l])
                # 计算当前位置的积水量，并累加到总结果中
                res += l_max - height[l]
            else:
                # 如果右边的最大高度小于等于左边的最大高度
                # 移动右指针
                r -= 1
                # 更新右指针处的最大高度
                r_max = max(r_max, height[r])
                # 计算当前位置的积水量，并累加到总结果中
                res += r_max - height[r]

        # 返回积水的总量
        return res
```

---

### 代码注释：

1. **初始化**：
   - 如果 `height` 数组为空，直接返回 0。
   - 使用 `l` 和 `r` 指针分别指向数组的最左端和最右端，初始化 `l_max` 和 `r_max` 为左右两端的高度。
   - 使用 `res` 来保存总积水量，初始化为 0。

2. **双指针移动**：
   - 当左指针 `l` 小于右指针 `r` 时，进入循环。
   - 如果左指针的最大高度 `l_max` 小于右指针的最大高度 `r_max`，说明左边的柱子限制了积水量，移动左指针。
   - 更新左边的最大高度 `l_max`，并计算当前位置的积水量。
   - 如果右边的最大高度 `r_max` 小于或等于左边的最大高度，说明右边的柱子限制了积水量，移动右指针。
   - 更新右边的最大高度 `r_max`，并计算当前位置的积水量。

3. **循环结束**：
   - 当左右指针相遇时，所有积水量已计算完毕，返回结果。

---

### 复杂度分析：

- **时间复杂度**：O(n)，其中 `n` 是数组 `height` 的长度。每个元素最多访问一次。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 示例分析：

对于输入 `height = [0,1,0,2,1,0,1,3,2,1,2,1]`：

1. 初始化左右指针：`l = 0`，`r = 11`，`l_max = 0`，`r_max = 1`。
2. 比较 `l_max` 和 `r_max`，由于 `l_max < r_max`，移动左指针并更新 `l_max`。
3. 移动指针并逐步计算积水，最终得到积水总量 6。

---

### 示例运行过程解析

给定输入：`height = [0,2,0,3,1,0,1,3,2,1]`

目标是计算这些柱子间可以接的雨水量，总和应该为 `9`。

### 代码逻辑逐步解析

初始化：
- 左指针 `l = 0`
- 右指针 `r = 9`（即数组最后一个位置）
- 左最大高度 `l_max = height[0] = 0`
- 右最大高度 `r_max = height[9] = 1`
- 答案变量 `ans = 0`，用于累积雨水量

### 运行过程逐步演示

1. **第一步**
   - 比较 `l_max (0)` 和 `r_max (1)`。
   - 因为 `l_max < r_max`，移动左指针：
     - `l += 1`，所以 `l = 1`
     - 更新 `l_max = max(l_max, height[1]) = max(0, 2) = 2`
     - 计算当前柱子的可接水量：`l_max - height[l] = 2 - 2 = 0`
     - `ans += 0`，因此 `ans = 0`

2. **第二步**
   - 比较 `l_max (2)` 和 `r_max (1)`。
   - 因为 `l_max > r_max`，移动右指针：
     - `r -= 1`，所以 `r = 8`
     - 更新 `r_max = max(r_max, height[8]) = max(1, 2) = 2`
     - 计算当前柱子的可接水量：`r_max - height[r] = 2 - 2 = 0`
     - `ans += 0`，因此 `ans = 0`

3. **第三步**
   - 比较 `l_max (2)` 和 `r_max (2)`。
   - 因为 `l_max = r_max`，移动右指针：
     - `r -= 1`，所以 `r = 7`
     - 更新 `r_max = max(r_max, height[7]) = max(2, 3) = 3`
     - 计算当前柱子的可接水量：`r_max - height[r] = 3 - 3 = 0`
     - `ans += 0`，因此 `ans = 0`

4. **第四步**
   - 比较 `l_max (2)` 和 `r_max (3)`。
   - 因为 `l_max < r_max`，移动左指针：
     - `l += 1`，所以 `l = 2`
     - 更新 `l_max = max(l_max, height[2]) = max(2, 0) = 2`
     - 计算当前柱子的可接水量：`l_max - height[l] = 2 - 0 = 2`
     - `ans += 2`，因此 `ans = 2`

5. **第五步**
   - 比较 `l_max (2)` 和 `r_max (3)`。
   - 因为 `l_max < r_max`，移动左指针：
     - `l += 1`，所以 `l = 3`
     - 更新 `l_max = max(l_max, height[3]) = max(2, 3) = 3`
     - 计算当前柱子的可接水量：`l_max - height[l] = 3 - 3 = 0`
     - `ans += 0`，因此 `ans = 2`

6. **第六步**
   - 比较 `l_max (3)` 和 `r_max (3)`。
   - 因为 `l_max = r_max`，移动右指针：
     - `r -= 1`，所以 `r = 6`
     - 更新 `r_max = max(r_max, height[6]) = max(3, 1) = 3`
     - 计算当前柱子的可接水量：`r_max - height[r] = 3 - 1 = 2`
     - `ans += 2`，因此 `ans = 4`

7. **第七步**
   - 比较 `l_max (3)` 和 `r_max (3)`。
   - 因为 `l_max = r_max`，移动右指针：
     - `r -= 1`，所以 `r = 5`
     - 更新 `r_max = max(r_max, height[5]) = max(3, 0) = 3`
     - 计算当前柱子的可接水量：`r_max - height[r] = 3 - 0 = 3`
     - `ans += 3`，因此 `ans = 7`

8. **第八步**
   - 比较 `l_max (3)` 和 `r_max (3)`。
   - 因为 `l_max = r_max`，移动右指针：
     - `r -= 1`，所以 `r = 4`
     - 更新 `r_max = max(r_max, height[4]) = max(3, 1) = 3`
     - 计算当前柱子的可接水量：`r_max - height[r] = 3 - 1 = 2`
     - `ans += 2`，因此 `ans = 9`

9. **第九步**
   - 比较 `l_max (3)` 和 `r_max (3)`。
   - 因为 `l_max = r_max`，移动右指针：
     - `r -= 1`，所以 `r = 3`

此时 `l >= r`，循环结束。

### 最终答案

- 计算得出最终的雨水总量 `ans = 9`

---

### 总结：

通过双指针法，我们可以一次遍历解决这个问题。利用两个指针动态维护左右两边的最大高度，保证每次只处理限制积水量的一侧，从而在 O(n) 的时间复杂度下计算出积水总量，并且只使用了常量空间。
