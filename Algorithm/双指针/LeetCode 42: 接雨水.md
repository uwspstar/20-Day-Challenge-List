### LeetCode 42: 接雨水

https://leetcode.com/problems/trapping-rain-water/

---

### 题目描述：

给定一个非负整数数组 `height`，数组中的每个元素表示墙的高度，每个柱子之间可以积水。你需要计算出这些柱子间能积多少雨水。

#### 示例：

```python
输入: height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

在这个例子中，柱子之间可以积水的区域总面积为 6。

---

### 解题思路：

使用**双指针法**，从左右两端向中间移动指针，动态维护当前左右两边的最大高度，来计算可以积水的区域。

#### 具体步骤：

1. **初始化指针**：使用两个指针，左指针 `l` 从左边开始，右指针 `r` 从右边开始。分别记录左边的最大高度 `l_max` 和右边的最大高度 `r_max`。
2. **移动指针**：每次比较左右指针的最大高度，选择较小的一侧进行处理。如果左侧高度较小，则移动左指针并更新左侧最大高度；反之移动右指针并更新右侧最大高度。
3. **计算积水量**：每次移动指针后，计算当前位置的积水量，并累加到总结果中。
4. **结束循环**：当左右指针相遇时，整个过程结束，返回积水总量。

---

### 代码实现（附详细注释）：

```python
from typing import List

class Solution:
    def trap(self, height: List[int]) -> int:
        # 如果高度数组为空，则无法积水，直接返回 0
        if not height:
            return 0

        # 初始化左右指针，左指针指向数组开头，右指针指向数组末尾
        l, r = 0, len(height) - 1
        # 分别初始化左右指针对应的最大高度
        l_max, r_max = height[l], height[r]

        # 初始化积水总量
        res = 0

        # 当左指针小于右指针时，继续计算积水
        while l < r:
            # 如果左边的最大高度小于右边的最大高度
            if l_max < r_max:
                # 移动左指针
                l += 1
                # 更新左指针处的最大高度
                l_max = max(l_max, height[l])
                # 计算当前位置的积水量，并累加到总结果中
                res += l_max - height[l]
            else:
                # 如果右边的最大高度小于等于左边的最大高度
                # 移动右指针
                r -= 1
                # 更新右指针处的最大高度
                r_max = max(r_max, height[r])
                # 计算当前位置的积水量，并累加到总结果中
                res += r_max - height[r]

        # 返回积水的总量
        return res
```

---

### 代码注释：

1. **初始化**：
   - 如果 `height` 数组为空，直接返回 0。
   - 使用 `l` 和 `r` 指针分别指向数组的最左端和最右端，初始化 `l_max` 和 `r_max` 为左右两端的高度。
   - 使用 `res` 来保存总积水量，初始化为 0。

2. **双指针移动**：
   - 当左指针 `l` 小于右指针 `r` 时，进入循环。
   - 如果左指针的最大高度 `l_max` 小于右指针的最大高度 `r_max`，说明左边的柱子限制了积水量，移动左指针。
   - 更新左边的最大高度 `l_max`，并计算当前位置的积水量。
   - 如果右边的最大高度 `r_max` 小于或等于左边的最大高度，说明右边的柱子限制了积水量，移动右指针。
   - 更新右边的最大高度 `r_max`，并计算当前位置的积水量。

3. **循环结束**：
   - 当左右指针相遇时，所有积水量已计算完毕，返回结果。

---

### 复杂度分析：

- **时间复杂度**：O(n)，其中 `n` 是数组 `height` 的长度。每个元素最多访问一次。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

---

### 示例分析：

对于输入 `height = [0,1,0,2,1,0,1,3,2,1,2,1]`：

1. 初始化左右指针：`l = 0`，`r = 11`，`l_max = 0`，`r_max = 1`。
2. 比较 `l_max` 和 `r_max`，由于 `l_max < r_max`，移动左指针并更新 `l_max`。
3. 移动指针并逐步计算积水，最终得到积水总量 6。

---

### 示例运行过程解析

给定输入：`height = [0,2,0,3,1,0,1,3,2,1]`

目标是计算这些柱子间可以接的雨水量，总和应该为 `9`。

### 代码逻辑逐步解析

初始化：
- 左指针 `l = 0`
- 右指针 `r = 9`（即数组最后一个位置）
- 左最大高度 `l_max = height[0] = 0`
- 右最大高度 `r_max = height[9] = 1`
- 答案变量 `ans = 0`，用于累积雨水量

### 运行过程逐步演示

1. **第一步**
   - 比较 `l_max (0)` 和 `r_max (1)`。
   - 因为 `l_max < r_max`，移动左指针：
     - `l += 1`，所以 `l = 1`
     - 更新 `l_max = max(l_max, height[1]) = max(0, 2) = 2`
     - 计算当前柱子的可接水量：`l_max - height[l] = 2 - 2 = 0`
     - `ans += 0`，因此 `ans = 0`

2. **第二步**
   - 比较 `l_max (2)` 和 `r_max (1)`。
   - 因为 `l_max > r_max`，移动右指针：
     - `r -= 1`，所以 `r = 8`
     - 更新 `r_max = max(r_max, height[8]) = max(1, 2) = 2`
     - 计算当前柱子的可接水量：`r_max - height[r] = 2 - 2 = 0`
     - `ans += 0`，因此 `ans = 0`

3. **第三步**
   - 比较 `l_max (2)` 和 `r_max (2)`。
   - 因为 `l_max = r_max`，移动右指针：
     - `r -= 1`，所以 `r = 7`
     - 更新 `r_max = max(r_max, height[7]) = max(2, 3) = 3`
     - 计算当前柱子的可接水量：`r_max - height[r] = 3 - 3 = 0`
     - `ans += 0`，因此 `ans = 0`

4. **第四步**
   - 比较 `l_max (2)` 和 `r_max (3)`。
   - 因为 `l_max < r_max`，移动左指针：
     - `l += 1`，所以 `l = 2`
     - 更新 `l_max = max(l_max, height[2]) = max(2, 0) = 2`
     - 计算当前柱子的可接水量：`l_max - height[l] = 2 - 0 = 2`
     - `ans += 2`，因此 `ans = 2`

5. **第五步**
   - 比较 `l_max (2)` 和 `r_max (3)`。
   - 因为 `l_max < r_max`，移动左指针：
     - `l += 1`，所以 `l = 3`
     - 更新 `l_max = max(l_max, height[3]) = max(2, 3) = 3`
     - 计算当前柱子的可接水量：`l_max - height[l] = 3 - 3 = 0`
     - `ans += 0`，因此 `ans = 2`

6. **第六步**
   - 比较 `l_max (3)` 和 `r_max (3)`。
   - 因为 `l_max = r_max`，移动右指针：
     - `r -= 1`，所以 `r = 6`
     - 更新 `r_max = max(r_max, height[6]) = max(3, 1) = 3`
     - 计算当前柱子的可接水量：`r_max - height[r] = 3 - 1 = 2`
     - `ans += 2`，因此 `ans = 4`

7. **第七步**
   - 比较 `l_max (3)` 和 `r_max (3)`。
   - 因为 `l_max = r_max`，移动右指针：
     - `r -= 1`，所以 `r = 5`
     - 更新 `r_max = max(r_max, height[5]) = max(3, 0) = 3`
     - 计算当前柱子的可接水量：`r_max - height[r] = 3 - 0 = 3`
     - `ans += 3`，因此 `ans = 7`

8. **第八步**
   - 比较 `l_max (3)` 和 `r_max (3)`。
   - 因为 `l_max = r_max`，移动右指针：
     - `r -= 1`，所以 `r = 4`
     - 更新 `r_max = max(r_max, height[4]) = max(3, 1) = 3`
     - 计算当前柱子的可接水量：`r_max - height[r] = 3 - 1 = 2`
     - `ans += 2`，因此 `ans = 9`

9. **第九步**
   - 比较 `l_max (3)` 和 `r_max (3)`。
   - 因为 `l_max = r_max`，移动右指针：
     - `r -= 1`，所以 `r = 3`

此时 `l >= r`，循环结束。

### 最终答案

- 计算得出最终的雨水总量 `ans = 9`

---

### 总结：

通过双指针法，我们可以一次遍历解决这个问题。利用两个指针动态维护左右两边的最大高度，保证每次只处理限制积水量的一侧，从而在 O(n) 的时间复杂度下计算出积水总量，并且只使用了常量空间。

---

好的，以下是将代码、为什么要先移动指针的解释、逐步示例和完整分析合并在一起的详细说明。

---

### 解题思路

1. **双指针法**：使用两个指针 `l` 和 `r` 分别从数组的两端向中心移动，逐步计算可以接的雨水量。
2. **维护左右最大高度**：使用 `l_max` 和 `r_max` 分别记录从左到右和从右到左的最大高度，以此来确定每个位置的积水量。
3. **选择移动的指针**：
   - 如果 `l_max < r_max`，则左侧的高度限制了当前积水量，因此可以确定左侧 `l` 位置的水量。此时移动左指针，继续计算左侧的积水。
   - 否则，如果 `l_max >= r_max`，右侧的高度限制了当前积水量，我们可以确定右侧的水量。因此移动右指针来继续计算右侧的积水。
4. **积水量计算顺序**：在每次计算积水量之前，**先移动指针**，再更新 `l_max` 或 `r_max`，然后再计算积水量。

---

### 为什么要先移动指针，再更新 `l_max` 和 `r_max`

1. **确保 `l_max` 和 `height[l]` 的值对应正确**：
   - 先移动指针，再更新 `l_max` 或 `r_max`，确保每次积水量计算的 `l_max` 或 `r_max` 和当前指针位置的高度 `height[l]` 或 `height[r]` 对应。
   - 如果先更新 `l_max`，再移动指针，那么 `l_max` 会基于旧位置的高度，而 `height[l]` 是新位置的高度，导致积水量计算错误。

2. **避免负值积水量**：
   - 积水量计算公式 `l_max - height[l]` 或 `r_max - height[r]` 假设 `l_max` 和 `height[l]` 是同一位置的数据。
   - 如果顺序错误，则可能导致 `l_max` 和 `height[l]` 不匹配，积水量可能为负数或不正确。

3. **正确的计算顺序**：
   - 先移动指针到新位置，然后计算新位置的 `l_max` 或 `r_max`，确保每次计算积水量时都基于新位置的正确高度。

---

### 代码实现

以下是正确的代码实现，确保先移动指针，再更新 `l_max` 和 `r_max`，然后计算积水量：

```python
from typing import List

class Solution:
    def trap(self, height: List[int]) -> int:
        l, r = 0, len(height) - 1
        l_max = height[l]
        r_max = height[r]
        ans = 0
        
        # 双指针循环
        while l < r:
            if l_max < r_max:
                # 移动左指针，然后更新 l_max 并计算积水量
                l += 1
                l_max = max(l_max, height[l])
                ans += l_max - height[l]
            else:
                # 移动右指针，然后更新 r_max 并计算积水量
                r -= 1
                r_max = max(r_max, height[r])
                ans += r_max - height[r]
        
        return ans
```

---

### 示例讲解：逐步解析示例步骤

假设输入 `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`，下面是代码执行过程的逐步解释：

1. **初始状态**：
   - 左指针 `l = 0`，右指针 `r = 11`
   - 左侧最大高度 `l_max = height[l] = 0`，右侧最大高度 `r_max = height[r] = 1`
   - 总接水量 `ans = 0`

2. **第 1 步**（`l_max < r_max`，移动左指针）：
   - `l += 1`，移动 `l` 到位置 `1`
   - 更新 `l_max = max(0, height[1]) = 1`
   - 当前积水量 `ans += l_max - height[1] = 1 - 1 = 0`
   - **当前状态**：`l = 1`，`r = 11`，`l_max = 1`，`r_max = 1`，`ans = 0`

3. **第 2 步**（`l_max >= r_max`，移动右指针）：
   - `r -= 1`，移动 `r` 到位置 `10`
   - 更新 `r_max = max(1, height[10]) = 2`
   - 当前积水量 `ans += r_max - height[10] = 2 - 2 = 0`
   - **当前状态**：`l = 1`，`r = 10`，`l_max = 1`，`r_max = 2`，`ans = 0`

4. **第 3 步**（`l_max < r_max`，移动左指针）：
   - `l += 1`，移动 `l` 到位置 `2`
   - 更新 `l_max = max(1, height[2]) = 1`
   - 当前积水量 `ans += l_max - height[2] = 1 - 0 = 1`
   - **当前状态**：`l = 2`，`r = 10`，`l_max = 1`，`r_max = 2`，`ans = 1`

5. **第 4 步**（`l_max < r_max`，移动左指针）：
   - `l += 1`，移动 `l` 到位置 `3`
   - 更新 `l_max = max(1, height[3]) = 2`
   - 当前积水量 `ans += l_max - height[3] = 2 - 2 = 0`
   - **当前状态**：`l = 3`，`r = 10`，`l_max = 2`，`r_max = 2`，`ans = 1`

6. **第 5 步**（`l_max >= r_max`，移动右指针）：
   - `r -= 1`，移动 `r` 到位置 `9`
   - 更新 `r_max = max(2, height[9]) = 2`
   - 当前积水量 `ans += r_max - height[9] = 2 - 1 = 1`
   - **当前状态**：`l = 3`，`r = 9`，`l_max = 2`，`r_max = 2`，`ans = 2`

7. **第 6 步**（`l_max >= r_max`，移动右指针）：
   - `r -= 1`，移动 `r` 到位置 `8`
   - 更新 `r_max = max(2, height[8]) = 2`
   - 当前积水量 `ans += r_max - height[8] = 2 - 2 = 0`
   - **当前状态**：`l = 3`，`r = 8`，`l_max = 2`，`r_max = 2`，`ans = 2`

8. **继续重复上述步骤，直到 `l` 和 `r` 相遇**。

---

### 总结

- **双指针法**：通过左右指针从两端向中心移动，动态更新左右最大高度 `l_max` 和 `r_max`，来计算可以接的雨水量。
- **先移动指针，再更新最大高度并计算积水量**：确保每次计算积水量时，`l_max` 或 `r_max` 与当前 `height[l]` 或 `height[r]` 对应，避免错误的积水量计算。
- **时间复杂度 O(n)**：因为每个位置最多只访问一次，整体复杂度为 O(n)。
- **空间复杂度 O(1)**：只需要常量空间来存储指针和最大高度，不需要额外空间。

通过正确的计算顺序，保证了积水量的准确计算。这种方法高效且简单，适合用于接雨水问题的解决。




