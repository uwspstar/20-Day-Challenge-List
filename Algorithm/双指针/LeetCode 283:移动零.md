### LeetCode 283: Move Zeroes（移动零）

https://leetcode.com/problems/move-zeroes/

**题目描述**：
给定一个数组 `nums`，编写一个函数将所有的 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。请注意，必须在原地修改输入数组，并且尽量减少操作次数。

**代码实现**：
```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        # 初始化双指针
        l, r = 0, 0
        
        # 遍历数组
        while r < len(nums):
            # 当右指针指向的元素不为0时，进行交换，将其移到前面
            if nums[r] != 0:
                nums[l], nums[r] = nums[r], nums[l]
                l += 1  # 左指针指向下一个应该交换的位置
            r += 1  # 右指针继续遍历数组
    
    # 另一个解法：拷贝非零元素并在尾部填充零
    def move_zeros(self, nums: List[int]) -> None:
        # 复制非零元素到前面
        i = 0
        for n in nums:
            if n != 0:
                nums[i] = n
                i += 1
        # 用 0 填充剩余部分
        while i < len(nums):
            nums[i] = 0
            i += 1
```

**新增的解决方案解释**：

- **解法 2：拷贝非零元素并在尾部填充零**：
  1. **遍历数组**：用 `i` 指针记录当前非零元素应该存放的位置。遍历数组，当发现一个非零元素时，将其赋值到 `nums[i]` 并递增 `i`。
  2. **填充零**：遍历完成后，`i` 指针后的所有位置都应该填充为 `0`，因此再进行一次循环，将从 `i` 开始的位置填充为 `0`。

**复杂度分析**：
- **时间复杂度**：O(n)，我们需要遍历数组两次，一次是拷贝非零元素，另一次是填充零。
- **空间复杂度**：O(1)，因为我们在原地操作数组，没有使用额外的存储空间。

**示例讲解**：

#### 示例 1:
```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```
- 第一次遍历数组，将非零元素 `[1, 3, 12]` 复制到数组的前面，`nums` 变为 `[1,3,12,3,12]`。
- 然后，从 `i = 3` 的位置开始填充零，最终得到 `[1,3,12,0,0]`。

#### 示例 2:
```
输入: nums = [0,0,1]
输出: [1,0,0]
```
- 第一次遍历数组，将唯一的非零元素 `1` 复制到数组的前面，`nums` 变为 `[1,0,1]`。
- 然后，从 `i = 1` 的位置开始填充零，最终得到 `[1,0,0]`。

**总结**：
- **解法 1（双指针法）** 可以在遍历过程中高效地完成移动操作，时间复杂度为 O(n)，空间复杂度为 O(1)。
- **解法 2（拷贝非零元素并填充零）** 也是一个常见的解决方案，通过两次遍历完成非零元素的移动和零的填充，时间复杂度为 O(n)，空间复杂度为 O(1)。
