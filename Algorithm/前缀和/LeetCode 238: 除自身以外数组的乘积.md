### LeetCode 238: 除自身以外数组的乘积 (Product of Array Except Self)

**题目描述**：  
给定一个整数数组 `nums`，返回一个数组 `answer`，其中 `answer[i]` 等于 `nums` 中除了 `nums[i]` 之外的其他元素的乘积。要求不使用除法，且时间复杂度为 O(n)。

[LeetCode 238: Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)

### 解题思路

为了满足题目要求（不使用除法且在 O(n) 时间复杂度内完成），我们可以使用**前缀积**和**后缀积**：

1. **前缀积**：从左到右计算前缀积，即数组中每个元素左侧所有元素的乘积。
2. **后缀积**：从右到左计算后缀积，即数组中每个元素右侧所有元素的乘积。
3. **结果数组**：使用 `answer[i] = prefix[i] * suffix[i]` 得到结果，其中 `prefix[i]` 是前缀积，`suffix[i]` 是后缀积。

这样，我们可以在一次遍历中计算前缀积，另一次遍历中计算后缀积，最后得到答案。

---

### 代码实现

```python
from typing import List

class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        # 初始化前缀乘积和后缀乘积为 1
        # prefix 用于计算当前元素左边所有元素的乘积
        # suffix 用于计算当前元素右边所有元素的乘积
        prefix, suffix = 1, 1
        # 创建一个与 nums 长度相同的结果数组 ans，并初始化为 1
        ans = [1] * len(nums)
        
        # 第一次遍历：计算前缀乘积
        # 遍历整个数组，从左到右依次计算每个位置的前缀乘积
        for i in range(len(nums)):
            # 将前缀乘积值赋给当前的 ans[i]，ans[i] 乘以当前的 prefix
            ans[i] *= prefix
            # 更新 prefix 值为包含当前 nums[i] 的前缀乘积
            prefix *= nums[i]
        
        # 第二次遍历：计算后缀乘积
        # 反向遍历整个数组，从右到左计算每个位置的后缀乘积
        for i in range(len(nums) - 1, -1, -1):
            # 将后缀乘积值赋给当前的 ans[i]，ans[i] 乘以当前的 suffix
            ans[i] *= suffix
            # 更新 suffix 值为包含当前 nums[i] 的后缀乘积
            suffix *= nums[i]

        # 返回计算完成的结果数组 ans
        return ans
```

### 复杂度分析

- **时间复杂度**：O(n)，我们只需要两次遍历数组。
- **空间复杂度**：O(1)，除了结果数组外，不使用额外空间（`ans` 不计入额外空间，因为它是输出）。

---

### 示例讲解：逐步解析示例步骤

假设我们有输入数组 `nums = [1, 2, 3, 4]`，下面我们逐步演示代码的执行过程：

#### 初始状态

- 输入数组 `nums = [1, 2, 3, 4]`
- 初始化 `prefix = 1` 和 `suffix = 1`
- 创建结果数组 `ans = [1, 1, 1, 1]`，初始时每个元素设为 `1`。

#### 第一次遍历 - 计算前缀乘积

**目标**：在 `ans` 数组的每个位置存储当前元素左侧所有元素的乘积。

**迭代过程**：

1. **第 1 步**（`i = 0`）：
   - `ans[0] *= prefix` → `ans[0] = 1 * 1 = 1`
   - 更新 `prefix *= nums[0]` → `prefix = 1 * 1 = 1`
   - 当前 `ans = [1, 1, 1, 1]`

2. **第 2 步**（`i = 1`）：
   - `ans[1] *= prefix` → `ans[1] = 1 * 1 = 1`
   - 更新 `prefix *= nums[1]` → `prefix = 1 * 2 = 2`
   - 当前 `ans = [1, 1, 1, 1]`

3. **第 3 步**（`i = 2`）：
   - `ans[2] *= prefix` → `ans[2] = 1 * 2 = 2`
   - 更新 `prefix *= nums[2]` → `prefix = 2 * 3 = 6`
   - 当前 `ans = [1, 1, 2, 1]`

4. **第 4 步**（`i = 3`）：
   - `ans[3] *= prefix` → `ans[3] = 1 * 6 = 6`
   - 更新 `prefix *= nums[3]` → `prefix = 6 * 4 = 24`
   - 当前 `ans = [1, 1, 2, 6]`

经过第一遍遍历，`ans` 数组的每个位置存储了该位置左侧所有元素的乘积，结果为 `ans = [1, 1, 2, 6]`。

#### 第二次遍历 - 计算后缀乘积

**目标**：将 `ans` 数组中的每个元素乘以当前元素右侧所有元素的乘积。

**迭代过程**：

1. **第 1 步**（`i = 3`）：
   - `ans[3] *= suffix` → `ans[3] = 6 * 1 = 6`
   - 更新 `suffix *= nums[3]` → `suffix = 1 * 4 = 4`
   - 当前 `ans = [1, 1, 2, 6]`

2. **第 2 步**（`i = 2`）：
   - `ans[2] *= suffix` → `ans[2] = 2 * 4 = 8`
   - 更新 `suffix *= nums[2]` → `suffix = 4 * 3 = 12`
   - 当前 `ans = [1, 1, 8, 6]`

3. **第 3 步**（`i = 1`）：
   - `ans[1] *= suffix` → `ans[1] = 1 * 12 = 12`
   - 更新 `suffix *= nums[1]` → `suffix = 12 * 2 = 24`
   - 当前 `ans = [1, 12, 8, 6]`

4. **第 4 步**（`i = 0`）：
   - `ans[0] *= suffix` → `ans[0] = 1 * 24 = 24`
   - 更新 `suffix *= nums[0]` → `suffix = 24 * 1 = 24`
   - 当前 `ans = [24, 12, 8, 6]`

### 最终结果

经过两次遍历，`ans` 数组中的每个元素即为除自身以外所有元素的乘积：

```python
ans = [24, 12, 8, 6]
```

---

### 总结

- **前缀乘积**和**后缀乘积**的思路可以有效地计算每个位置除自身外所有元素的乘积。
- 通过两次遍历，在 O(n) 时间复杂度内完成计算。
- 最终结果 `ans = [24, 12, 8, 6]` 对应的是每个位置除自身外其他所有元素的乘积：  
  - `ans[0] = 24`：`2 * 3 * 4`
  - `ans[1] = 12`：`1 * 3 * 4`
  - `ans[2] = 8`：`1 * 2 * 4`
  - `ans[3] = 6`：`1 * 2 * 3`
