# 函数参数的传递
在 Python 中，函数参数的传递行为有时会导致混淆，尤其是关于“按值传递”和“按引用传递”的术语。Python 的参数传递实际上是“按共享传递”（pass-by-sharing），这意味着函数接收的参数是实际数据（或对象）的引用，而不是它们的副本。这种方式有时被非正式地称为“按对象引用传递”。

### 关键概念

1. **实际参数的传递**: 当函数被调用时，实际使用的参数（或称为实参）会被传入到函数的局部符号表中。这些参数是对象的引用，而不是对象本身的副本。

2. **局部符号表**: 每当一个函数被调用时，Python 会为该函数创建一个新的局部符号表。这个符号表包含函数内的变量名和它们对应的值（实际上是引用）。

3. **按共享传递的含义**: 这意味着如果你在函数内修改了作为参数传入的可变对象（如列表或字典），那么这些修改会反映到调用者的环境中。但如果尝试重新绑定一个参数（例如，将一个整数参数设置为一个新的值），这将仅仅改变局部符号表中的引用，而不会影响外部的对象。

### 示例

下面的例子将帮助阐明这些概念：

#### 示例 1：修改可变对象

```python
def modify_list(lst):
    lst.append(3)  # 修改传入的列表

my_list = [1, 2]
modify_list(my_list)
print(my_list)  # 输出: [1, 2, 3]
```

**解释**:
- `modify_list` 函数接收一个列表，并向其中添加一个元素。因为列表是可变的，所以传入的是引用，列表的修改在函数外也可见。

#### 示例 2：尝试修改不可变对象

```python
def modify_number(x):
    x = 10  # 尝试修改传入的数字

num = 5
modify_number(num)
print(num)  # 输出: 5
```

**解释**:
- 尽管函数内部的 `x` 被重新赋值为 10，这种修改只影响函数的局部符号表中的 `x`。外部的 `num` 仍然是 5，因为整数是不可变的，并且重新赋值创建了一个新的局部引用，而不是修改原始对象。

### 解释 | 解释

Python 中的函数参数传递通常是按引用传递的，但这种引用是对象引用的副本。这意味着对可变对象的修改在函数外部是可见的，但直接对参数变量重新赋值（即更改引用）不会影响原始外部变量。理解这一点对于编写有效和预期的行为一致的 Python 代码至关重要。
